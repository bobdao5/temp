import{r as ze}from"./buffer-bc4dc455.js";import{r as We}from"./@noble-40b92da4.js";import{r as Fe}from"./events-594410aa.js";import{r as xe}from"./micro-ftch-09045f9d.js";var D=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function at(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function dt(e){if(e.__esModule)return e;var c=e.default;if(typeof c=="function"){var n=function y(){if(this instanceof y){var a=[null];a.push.apply(a,arguments);var r=Function.bind.apply(c,a);return new r}return c.apply(this,arguments)};n.prototype=c.prototype}else n={};return Object.defineProperty(n,"__esModule",{value:!0}),Object.keys(e).forEach(function(y){var a=Object.getOwnPropertyDescriptor(e,y);Object.defineProperty(n,y,a.get?a:{enumerable:!0,get:function(){return e[y]}})}),n}function he(e){throw new Error('Could not dynamically require "'+e+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var ee={},te={},re={},ge;function ae(){return ge||(ge=1,function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.secp256k1=void 0;var c=We();Object.defineProperty(e,"secp256k1",{enumerable:!0,get:function(){return c.secp256k1}})}(re)),re}var ye;function de(){return ye||(ye=1,function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.MAX_WITHDRAWALS_PER_PAYLOAD=e.RLP_EMPTY_STRING=e.KECCAK256_RLP=e.KECCAK256_RLP_S=e.KECCAK256_RLP_ARRAY=e.KECCAK256_RLP_ARRAY_S=e.KECCAK256_NULL=e.KECCAK256_NULL_S=e.TWO_POW256=e.SECP256K1_ORDER_DIV_2=e.SECP256K1_ORDER=e.MAX_INTEGER_BIGINT=e.MAX_INTEGER=e.MAX_UINT64=void 0;const c=ze(),n=ae();e.MAX_UINT64=BigInt("0xffffffffffffffff"),e.MAX_INTEGER=BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),e.MAX_INTEGER_BIGINT=BigInt("115792089237316195423570985008687907853269984665640564039457584007913129639935"),e.SECP256K1_ORDER=n.secp256k1.CURVE.n,e.SECP256K1_ORDER_DIV_2=n.secp256k1.CURVE.n/BigInt(2),e.TWO_POW256=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000"),e.KECCAK256_NULL_S="c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470",e.KECCAK256_NULL=c.Buffer.from(e.KECCAK256_NULL_S,"hex"),e.KECCAK256_RLP_ARRAY_S="1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347",e.KECCAK256_RLP_ARRAY=c.Buffer.from(e.KECCAK256_RLP_ARRAY_S,"hex"),e.KECCAK256_RLP_S="56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421",e.KECCAK256_RLP=c.Buffer.from(e.KECCAK256_RLP_S,"hex"),e.RLP_EMPTY_STRING=c.Buffer.from([128]),e.MAX_WITHDRAWALS_PER_PAYLOAD=16}(te)),te}var W={},be;function Xe(){return be||(be=1,Object.defineProperty(W,"__esModule",{value:!0}),W.GWEI_TO_WEI=void 0,W.GWEI_TO_WEI=BigInt(1e9)),W}var ne={},N={},Be;function Ge(){if(Be)return N;Be=1,Object.defineProperty(N,"__esModule",{value:!0}),N.RLP=N.utils=N.decode=N.encode=void 0;function e(u){if(Array.isArray(u)){const E=[];let B=0;for(let l=0;l<u.length;l++){const i=e(u[l]);E.push(i),B+=i.length}return b(y(B,192),...E)}const g=O(u);return g.length===1&&g[0]<128?g:b(y(g.length,128),g)}N.encode=e;function c(u,g,E){if(E>u.length)throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");return u.slice(g,E)}function n(u){if(u[0]===0)throw new Error("invalid RLP: extra zeros");return h(f(u))}function y(u,g){if(u<56)return Uint8Array.from([u+g]);const E=v(u),B=E.length/2,l=v(g+55+B);return Uint8Array.from(_(l+E))}function a(u,g=!1){if(typeof u>"u"||u===null||u.length===0)return Uint8Array.from([]);const E=O(u),B=r(E);if(g)return B;if(B.remainder.length!==0)throw new Error("invalid RLP: remainder must be zero");return B.data}N.decode=a;function r(u){let g,E,B,l,i;const w=[],T=u[0];if(T<=127)return{data:u.slice(0,1),remainder:u.slice(1)};if(T<=183){if(g=T-127,T===128?B=Uint8Array.from([]):B=c(u,1,g),g===2&&B[0]<128)throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");return{data:B,remainder:u.slice(g)}}else if(T<=191){if(E=T-182,u.length-1<E)throw new Error("invalid RLP: not enough bytes for string length");if(g=n(c(u,1,E)),g<=55)throw new Error("invalid RLP: expected string length to be greater than 55");return B=c(u,E,g+E),{data:B,remainder:u.slice(g+E)}}else if(T<=247){for(g=T-191,l=c(u,1,g);l.length;)i=r(l),w.push(i.data),l=i.remainder;return{data:w,remainder:u.slice(g)}}else{if(E=T-246,g=n(c(u,1,E)),g<56)throw new Error("invalid RLP: encoded list too short");const P=E+g;if(P>u.length)throw new Error("invalid RLP: total length is larger than the data");for(l=c(u,E,P);l.length;)i=r(l),w.push(i.data),l=i.remainder;return{data:w,remainder:u.slice(P)}}}const o=Array.from({length:256},(u,g)=>g.toString(16).padStart(2,"0"));function f(u){let g="";for(let E=0;E<u.length;E++)g+=o[u[E]];return g}function h(u){const g=Number.parseInt(u,16);if(Number.isNaN(g))throw new Error("Invalid byte sequence");return g}function _(u){if(typeof u!="string")throw new TypeError("hexToBytes: expected string, got "+typeof u);if(u.length%2)throw new Error("hexToBytes: received invalid unpadded hex");const g=new Uint8Array(u.length/2);for(let E=0;E<g.length;E++){const B=E*2;g[E]=h(u.slice(B,B+2))}return g}function b(...u){if(u.length===1)return u[0];const g=u.reduce((B,l)=>B+l.length,0),E=new Uint8Array(g);for(let B=0,l=0;B<u.length;B++){const i=u[B];E.set(i,l),l+=i.length}return E}function L(u){return new TextEncoder().encode(u)}function v(u){if(u<0)throw new Error("Invalid integer as argument, must be unsigned!");const g=u.toString(16);return g.length%2?`0${g}`:g}function S(u){return u.length%2?`0${u}`:u}function p(u){return u.length>=2&&u[0]==="0"&&u[1]==="x"}function k(u){return typeof u!="string"?u:p(u)?u.slice(2):u}function O(u){if(u instanceof Uint8Array)return u;if(typeof u=="string")return p(u)?_(S(k(u))):L(u);if(typeof u=="number"||typeof u=="bigint")return u?_(v(u)):Uint8Array.from([]);if(u==null)return Uint8Array.from([]);throw new Error("toBytes: received unsupported type "+typeof u)}return N.utils={bytesToHex:f,concatBytes:b,hexToBytes:_,utf8ToBytes:L},N.RLP={encode:e,decode:a},N}var M={},H={},q={},we;function Ne(){if(we)return q;we=1,Object.defineProperty(q,"__esModule",{value:!0}),q.output=q.exists=q.hash=q.bytes=q.bool=q.number=void 0;function e(f){if(!Number.isSafeInteger(f)||f<0)throw new Error(`Wrong positive integer: ${f}`)}q.number=e;function c(f){if(typeof f!="boolean")throw new Error(`Expected boolean, not ${f}`)}q.bool=c;function n(f,...h){if(!(f instanceof Uint8Array))throw new Error("Expected Uint8Array");if(h.length>0&&!h.includes(f.length))throw new Error(`Expected Uint8Array of length ${h}, not of length=${f.length}`)}q.bytes=n;function y(f){if(typeof f!="function"||typeof f.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");e(f.outputLen),e(f.blockLen)}q.hash=y;function a(f,h=!0){if(f.destroyed)throw new Error("Hash instance has been destroyed");if(h&&f.finished)throw new Error("Hash#digest() has already been called")}q.exists=a;function r(f,h){n(f);const _=h.outputLen;if(f.length<_)throw new Error(`digestInto() expects output buffer of length at least ${_}`)}q.output=r;const o={number:e,bool:c,bytes:n,hash:y,exists:a,output:r};return q.default=o,q}var ie={},me;function Ye(){return me||(me=1,function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.add=e.toBig=e.split=e.fromBig=void 0;const c=BigInt(2**32-1),n=BigInt(32);function y(d,m=!1){return m?{h:Number(d&c),l:Number(d>>n&c)}:{h:Number(d>>n&c)|0,l:Number(d&c)|0}}e.fromBig=y;function a(d,m=!1){let s=new Uint32Array(d.length),I=new Uint32Array(d.length);for(let t=0;t<d.length;t++){const{h:A,l:R}=y(d[t],m);[s[t],I[t]]=[A,R]}return[s,I]}e.split=a;const r=(d,m)=>BigInt(d>>>0)<<n|BigInt(m>>>0);e.toBig=r;const o=(d,m,s)=>d>>>s,f=(d,m,s)=>d<<32-s|m>>>s,h=(d,m,s)=>d>>>s|m<<32-s,_=(d,m,s)=>d<<32-s|m>>>s,b=(d,m,s)=>d<<64-s|m>>>s-32,L=(d,m,s)=>d>>>s-32|m<<64-s,v=(d,m)=>m,S=(d,m)=>d,p=(d,m,s)=>d<<s|m>>>32-s,k=(d,m,s)=>m<<s|d>>>32-s,O=(d,m,s)=>m<<s-32|d>>>64-s,u=(d,m,s)=>d<<s-32|m>>>64-s;function g(d,m,s,I){const t=(m>>>0)+(I>>>0);return{h:d+s+(t/2**32|0)|0,l:t|0}}e.add=g;const E=(d,m,s)=>(d>>>0)+(m>>>0)+(s>>>0),B=(d,m,s,I)=>m+s+I+(d/2**32|0)|0,l=(d,m,s,I)=>(d>>>0)+(m>>>0)+(s>>>0)+(I>>>0),i=(d,m,s,I,t)=>m+s+I+t+(d/2**32|0)|0,w=(d,m,s,I,t)=>(d>>>0)+(m>>>0)+(s>>>0)+(I>>>0)+(t>>>0),T=(d,m,s,I,t,A)=>m+s+I+t+A+(d/2**32|0)|0,P={fromBig:y,split:a,toBig:e.toBig,shrSH:o,shrSL:f,rotrSH:h,rotrSL:_,rotrBH:b,rotrBL:L,rotr32H:v,rotr32L:S,rotlSH:p,rotlSL:k,rotlBH:O,rotlBL:u,add:g,add3L:E,add3H:B,add4L:l,add4H:i,add5H:T,add5L:w};e.default=P}(ie)),ie}var oe={},F={},Ae;function Ze(){return Ae||(Ae=1,Object.defineProperty(F,"__esModule",{value:!0}),F.crypto=void 0,F.crypto=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0),F}var _e;function ce(){return _e||(_e=1,function(e){/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */Object.defineProperty(e,"__esModule",{value:!0}),e.randomBytes=e.wrapXOFConstructorWithOpts=e.wrapConstructorWithOpts=e.wrapConstructor=e.checkOpts=e.Hash=e.concatBytes=e.toBytes=e.utf8ToBytes=e.asyncLoop=e.nextTick=e.hexToBytes=e.bytesToHex=e.isLE=e.rotr=e.createView=e.u32=e.u8=void 0;const c=Ze(),n=i=>i instanceof Uint8Array,y=i=>new Uint8Array(i.buffer,i.byteOffset,i.byteLength);e.u8=y;const a=i=>new Uint32Array(i.buffer,i.byteOffset,Math.floor(i.byteLength/4));e.u32=a;const r=i=>new DataView(i.buffer,i.byteOffset,i.byteLength);e.createView=r;const o=(i,w)=>i<<32-w|i>>>w;if(e.rotr=o,e.isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68,!e.isLE)throw new Error("Non little-endian hardware is not supported");const f=Array.from({length:256},(i,w)=>w.toString(16).padStart(2,"0"));function h(i){if(!n(i))throw new Error("Uint8Array expected");let w="";for(let T=0;T<i.length;T++)w+=f[i[T]];return w}e.bytesToHex=h;function _(i){if(typeof i!="string")throw new Error("hex string expected, got "+typeof i);const w=i.length;if(w%2)throw new Error("padded hex string expected, got unpadded hex of length "+w);const T=new Uint8Array(w/2);for(let P=0;P<T.length;P++){const d=P*2,m=i.slice(d,d+2),s=Number.parseInt(m,16);if(Number.isNaN(s)||s<0)throw new Error("Invalid byte sequence");T[P]=s}return T}e.hexToBytes=_;const b=async()=>{};e.nextTick=b;async function L(i,w,T){let P=Date.now();for(let d=0;d<i;d++){T(d);const m=Date.now()-P;m>=0&&m<w||(await(0,e.nextTick)(),P+=m)}}e.asyncLoop=L;function v(i){if(typeof i!="string")throw new Error(`utf8ToBytes expected string, got ${typeof i}`);return new Uint8Array(new TextEncoder().encode(i))}e.utf8ToBytes=v;function S(i){if(typeof i=="string"&&(i=v(i)),!n(i))throw new Error(`expected Uint8Array, got ${typeof i}`);return i}e.toBytes=S;function p(...i){const w=new Uint8Array(i.reduce((P,d)=>P+d.length,0));let T=0;return i.forEach(P=>{if(!n(P))throw new Error("Uint8Array expected");w.set(P,T),T+=P.length}),w}e.concatBytes=p;class k{clone(){return this._cloneInto()}}e.Hash=k;const O=i=>Object.prototype.toString.call(i)==="[object Object]"&&i.constructor===Object;function u(i,w){if(w!==void 0&&(typeof w!="object"||!O(w)))throw new Error("Options should be object or undefined");return Object.assign(i,w)}e.checkOpts=u;function g(i){const w=P=>i().update(S(P)).digest(),T=i();return w.outputLen=T.outputLen,w.blockLen=T.blockLen,w.create=()=>i(),w}e.wrapConstructor=g;function E(i){const w=(P,d)=>i(d).update(S(P)).digest(),T=i({});return w.outputLen=T.outputLen,w.blockLen=T.blockLen,w.create=P=>i(P),w}e.wrapConstructorWithOpts=E;function B(i){const w=(P,d)=>i(d).update(S(P)).digest(),T=i({});return w.outputLen=T.outputLen,w.blockLen=T.blockLen,w.create=P=>i(P),w}e.wrapXOFConstructorWithOpts=B;function l(i=32){if(c.crypto&&typeof c.crypto.getRandomValues=="function")return c.crypto.getRandomValues(new Uint8Array(i));throw new Error("crypto.getRandomValues must be defined")}e.randomBytes=l}(oe)),oe}var Te;function Je(){if(Te)return H;Te=1,Object.defineProperty(H,"__esModule",{value:!0}),H.shake256=H.shake128=H.keccak_512=H.keccak_384=H.keccak_256=H.keccak_224=H.sha3_512=H.sha3_384=H.sha3_256=H.sha3_224=H.Keccak=H.keccakP=void 0;const e=Ne(),c=Ye(),n=ce(),[y,a,r]=[[],[],[]],o=BigInt(0),f=BigInt(1),h=BigInt(2),_=BigInt(7),b=BigInt(256),L=BigInt(113);for(let B=0,l=f,i=1,w=0;B<24;B++){[i,w]=[w,(2*i+3*w)%5],y.push(2*(5*w+i)),a.push((B+1)*(B+2)/2%64);let T=o;for(let P=0;P<7;P++)l=(l<<f^(l>>_)*L)%b,l&h&&(T^=f<<(f<<BigInt(P))-f);r.push(T)}const[v,S]=c.default.split(r,!0),p=(B,l,i)=>i>32?c.default.rotlBH(B,l,i):c.default.rotlSH(B,l,i),k=(B,l,i)=>i>32?c.default.rotlBL(B,l,i):c.default.rotlSL(B,l,i);function O(B,l=24){const i=new Uint32Array(10);for(let w=24-l;w<24;w++){for(let d=0;d<10;d++)i[d]=B[d]^B[d+10]^B[d+20]^B[d+30]^B[d+40];for(let d=0;d<10;d+=2){const m=(d+8)%10,s=(d+2)%10,I=i[s],t=i[s+1],A=p(I,t,1)^i[m],R=k(I,t,1)^i[m+1];for(let j=0;j<50;j+=10)B[d+j]^=A,B[d+j+1]^=R}let T=B[2],P=B[3];for(let d=0;d<24;d++){const m=a[d],s=p(T,P,m),I=k(T,P,m),t=y[d];T=B[t],P=B[t+1],B[t]=s,B[t+1]=I}for(let d=0;d<50;d+=10){for(let m=0;m<10;m++)i[m]=B[d+m];for(let m=0;m<10;m++)B[d+m]^=~i[(m+2)%10]&i[(m+4)%10]}B[0]^=v[w],B[1]^=S[w]}i.fill(0)}H.keccakP=O;class u extends n.Hash{constructor(l,i,w,T=!1,P=24){if(super(),this.blockLen=l,this.suffix=i,this.outputLen=w,this.enableXOF=T,this.rounds=P,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,e.default.number(w),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=(0,n.u32)(this.state)}keccak(){O(this.state32,this.rounds),this.posOut=0,this.pos=0}update(l){e.default.exists(this);const{blockLen:i,state:w}=this;l=(0,n.toBytes)(l);const T=l.length;for(let P=0;P<T;){const d=Math.min(i-this.pos,T-P);for(let m=0;m<d;m++)w[this.pos++]^=l[P++];this.pos===i&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:l,suffix:i,pos:w,blockLen:T}=this;l[w]^=i,i&128&&w===T-1&&this.keccak(),l[T-1]^=128,this.keccak()}writeInto(l){e.default.exists(this,!1),e.default.bytes(l),this.finish();const i=this.state,{blockLen:w}=this;for(let T=0,P=l.length;T<P;){this.posOut>=w&&this.keccak();const d=Math.min(w-this.posOut,P-T);l.set(i.subarray(this.posOut,this.posOut+d),T),this.posOut+=d,T+=d}return l}xofInto(l){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(l)}xof(l){return e.default.number(l),this.xofInto(new Uint8Array(l))}digestInto(l){if(e.default.output(l,this),this.finished)throw new Error("digest() was already called");return this.writeInto(l),this.destroy(),l}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(l){const{blockLen:i,suffix:w,outputLen:T,rounds:P,enableXOF:d}=this;return l||(l=new u(i,w,T,d,P)),l.state32.set(this.state32),l.pos=this.pos,l.posOut=this.posOut,l.finished=this.finished,l.rounds=P,l.suffix=w,l.outputLen=T,l.enableXOF=d,l.destroyed=this.destroyed,l}}H.Keccak=u;const g=(B,l,i)=>(0,n.wrapConstructor)(()=>new u(l,B,i));H.sha3_224=g(6,144,224/8),H.sha3_256=g(6,136,256/8),H.sha3_384=g(6,104,384/8),H.sha3_512=g(6,72,512/8),H.keccak_224=g(1,144,224/8),H.keccak_256=g(1,136,256/8),H.keccak_384=g(1,104,384/8),H.keccak_512=g(1,72,512/8);const E=(B,l,i)=>(0,n.wrapXOFConstructorWithOpts)((w={})=>new u(l,B,w.dkLen===void 0?i:w.dkLen,!0));return H.shake128=E(31,168,128/8),H.shake256=E(31,136,256/8),H}var Z={},Qe={get exports(){return Z},set exports(e){Z=e}},pe;function Me(){return pe||(pe=1,function(e,c){var n=D&&D.__importDefault||function(v){return v&&v.__esModule?v:{default:v}};Object.defineProperty(c,"__esModule",{value:!0}),c.crypto=c.wrapHash=c.equalsBytes=c.hexToBytes=c.bytesToUtf8=c.utf8ToBytes=c.createView=c.concatBytes=c.toHex=c.bytesToHex=c.assertBytes=c.assertBool=void 0;const y=n(Ne()),a=ce(),r=y.default.bool;c.assertBool=r;const o=y.default.bytes;c.assertBytes=o;var f=ce();Object.defineProperty(c,"bytesToHex",{enumerable:!0,get:function(){return f.bytesToHex}}),Object.defineProperty(c,"toHex",{enumerable:!0,get:function(){return f.bytesToHex}}),Object.defineProperty(c,"concatBytes",{enumerable:!0,get:function(){return f.concatBytes}}),Object.defineProperty(c,"createView",{enumerable:!0,get:function(){return f.createView}}),Object.defineProperty(c,"utf8ToBytes",{enumerable:!0,get:function(){return f.utf8ToBytes}});function h(v){if(!(v instanceof Uint8Array))throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof v}`);return new TextDecoder().decode(v)}c.bytesToUtf8=h;function _(v){const S=v.startsWith("0x")?v.substring(2):v;return(0,a.hexToBytes)(S)}c.hexToBytes=_;function b(v,S){if(v.length!==S.length)return!1;for(let p=0;p<v.length;p++)if(v[p]!==S[p])return!1;return!0}c.equalsBytes=b;function L(v){return S=>(y.default.bytes(S),v(S))}c.wrapHash=L,c.crypto=(()=>{const v=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0,S=typeof he=="function"&&he.bind(e);return{node:S&&!v?S("crypto"):void 0,web:v}})()}(Qe,Z)),Z}var ve;function Ke(){if(ve)return M;ve=1,Object.defineProperty(M,"__esModule",{value:!0}),M.keccak512=M.keccak384=M.keccak256=M.keccak224=void 0;const e=Je(),c=Me();return M.keccak224=(0,c.wrapHash)(e.keccak_224),M.keccak256=(()=>{const n=(0,c.wrapHash)(e.keccak_256);return n.create=e.keccak_256.create,n})(),M.keccak384=(0,c.wrapHash)(e.keccak_384),M.keccak512=(0,c.wrapHash)(e.keccak_512),M}var fe={},K={},C={},Ie;function J(){if(Ie)return C;Ie=1,Object.defineProperty(C,"__esModule",{value:!0}),C.isHexString=C.getKeys=C.fromAscii=C.fromUtf8=C.toAscii=C.arrayContainsArray=C.getBinarySize=C.padToEven=C.stripHexPrefix=C.isHexPrefixed=void 0;function e(b){if(typeof b!="string")throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof b}`);return b[0]==="0"&&b[1]==="x"}C.isHexPrefixed=e;const c=b=>{if(typeof b!="string")throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof b}`);return e(b)?b.slice(2):b};C.stripHexPrefix=c;function n(b){let L=b;if(typeof L!="string")throw new Error(`[padToEven] value must be type 'string', received ${typeof L}`);return L.length%2&&(L=`0${L}`),L}C.padToEven=n;function y(b){if(typeof b!="string")throw new Error(`[getBinarySize] method requires input type 'string', received ${typeof b}`);return Buffer.byteLength(b,"utf8")}C.getBinarySize=y;function a(b,L,v){if(Array.isArray(b)!==!0)throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof b}'`);if(Array.isArray(L)!==!0)throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof L}'`);return L[v===!0?"some":"every"](S=>b.indexOf(S)>=0)}C.arrayContainsArray=a;function r(b){let L="",v=0;const S=b.length;for(b.substring(0,2)==="0x"&&(v=2);v<S;v+=2){const p=parseInt(b.substr(v,2),16);L+=String.fromCharCode(p)}return L}C.toAscii=r;function o(b){const L=Buffer.from(b,"utf8");return`0x${n(L.toString("hex")).replace(/^0+|0+$/g,"")}`}C.fromUtf8=o;function f(b){let L="";for(let v=0;v<b.length;v++){const p=b.charCodeAt(v).toString(16);L+=p.length<2?`0${p}`:p}return`0x${L}`}C.fromAscii=f;function h(b,L,v){if(!Array.isArray(b))throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof b}`);if(typeof L!="string")throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof b}`);const S=[];for(let p=0;p<b.length;p++){let k=b[p][L];if(v===!0&&!k)k="";else if(typeof k!="string")throw new Error(`invalid abi - expected type 'string', received ${typeof k}`);S.push(k)}return S}C.getKeys=h;function _(b,L){return!(typeof b!="string"||!b.match(/^0x[0-9A-Fa-f]*$/)||typeof L<"u"&&L>0&&b.length!==2+2*L)}return C.isHexString=_,C}var Ee;function le(){if(Ee)return K;Ee=1,Object.defineProperty(K,"__esModule",{value:!0}),K.assertIsString=K.assertIsArray=K.assertIsBuffer=K.assertIsHexString=void 0;const e=J(),c=function(r){if(!(0,e.isHexString)(r)){const o=`This method only supports 0x-prefixed hex strings but input was: ${r}`;throw new Error(o)}};K.assertIsHexString=c;const n=function(r){if(!Buffer.isBuffer(r)){const o=`This method only supports Buffer but input was: ${r}`;throw new Error(o)}};K.assertIsBuffer=n;const y=function(r){if(!Array.isArray(r)){const o=`This method only supports number arrays but input was: ${r}`;throw new Error(o)}};K.assertIsArray=y;const a=function(r){if(typeof r!="string"){const o=`This method only supports strings but input was: ${r}`;throw new Error(o)}};return K.assertIsString=a,K}var Pe;function z(){return Pe||(Pe=1,function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.intToUnpaddedBuffer=e.bigIntToUnpaddedBuffer=e.bigIntToHex=e.bufArrToArr=e.arrToBufArr=e.validateNoLeadingZeroes=e.baToJSON=e.toUtf8=e.short=e.addHexPrefix=e.toUnsigned=e.fromSigned=e.bufferToInt=e.bigIntToBuffer=e.bufferToBigInt=e.bufferToHex=e.toBuffer=e.unpadHexString=e.unpadArray=e.unpadBuffer=e.setLengthRight=e.setLengthLeft=e.zeros=e.intToBuffer=e.intToHex=void 0;const c=le(),n=J(),y=function(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Received an invalid integer type: ${t}`);return`0x${t.toString(16)}`};e.intToHex=y;const a=function(t){const A=(0,e.intToHex)(t);return Buffer.from((0,n.padToEven)(A.slice(2)),"hex")};e.intToBuffer=a;const r=function(t){return Buffer.allocUnsafe(t).fill(0)};e.zeros=r;const o=function(t,A,R){const j=(0,e.zeros)(A);return R?t.length<A?(t.copy(j),j):t.slice(0,A):t.length<A?(t.copy(j,A-t.length),j):t.slice(-A)},f=function(t,A){return(0,c.assertIsBuffer)(t),o(t,A,!1)};e.setLengthLeft=f;const h=function(t,A){return(0,c.assertIsBuffer)(t),o(t,A,!0)};e.setLengthRight=h;const _=function(t){let A=t[0];for(;t.length>0&&A.toString()==="0";)t=t.slice(1),A=t[0];return t},b=function(t){return(0,c.assertIsBuffer)(t),_(t)};e.unpadBuffer=b;const L=function(t){return(0,c.assertIsArray)(t),_(t)};e.unpadArray=L;const v=function(t){return(0,c.assertIsHexString)(t),t=(0,n.stripHexPrefix)(t),"0x"+_(t)};e.unpadHexString=v;const S=function(t){if(t==null)return Buffer.allocUnsafe(0);if(Buffer.isBuffer(t)||Array.isArray(t)||t instanceof Uint8Array)return Buffer.from(t);if(typeof t=="string"){if(!(0,n.isHexString)(t))throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${t}`);return Buffer.from((0,n.padToEven)((0,n.stripHexPrefix)(t)),"hex")}if(typeof t=="number")return(0,e.intToBuffer)(t);if(typeof t=="bigint"){if(t<BigInt(0))throw new Error(`Cannot convert negative bigint to buffer. Given: ${t}`);let A=t.toString(16);return A.length%2&&(A="0"+A),Buffer.from(A,"hex")}if(t.toArray)return Buffer.from(t.toArray());if(t.toBuffer)return Buffer.from(t.toBuffer());throw new Error("invalid type")};e.toBuffer=S;const p=function(t){return t=(0,e.toBuffer)(t),"0x"+t.toString("hex")};e.bufferToHex=p;function k(t){const A=(0,e.bufferToHex)(t);return BigInt(A==="0x"?0:A)}e.bufferToBigInt=k;function O(t){return(0,e.toBuffer)("0x"+t.toString(16))}e.bigIntToBuffer=O;const u=function(t){const A=Number(k(t));if(!Number.isSafeInteger(A))throw new Error("Number exceeds 53 bits");return A};e.bufferToInt=u;const g=function(t){return BigInt.asIntN(256,k(t))};e.fromSigned=g;const E=function(t){return O(BigInt.asUintN(256,t))};e.toUnsigned=E;const B=function(t){return typeof t!="string"||(0,n.isHexPrefixed)(t)?t:"0x"+t};e.addHexPrefix=B;function l(t,A=50){const R=Buffer.isBuffer(t)?t.toString("hex"):t;return R.length<=A?R:R.slice(0,A)+"â€¦"}e.short=l;const i=function(t){const A=/^(00)+|(00)+$/g;if(t=(0,n.stripHexPrefix)(t),t.length%2!==0)throw new Error("Invalid non-even hex string input for toUtf8() provided");return Buffer.from(t.replace(A,""),"hex").toString("utf8")};e.toUtf8=i;const w=function(t){if(Buffer.isBuffer(t))return`0x${t.toString("hex")}`;if(t instanceof Array){const A=[];for(let R=0;R<t.length;R++)A.push((0,e.baToJSON)(t[R]));return A}};e.baToJSON=w;const T=function(t){for(const[A,R]of Object.entries(t))if(R!==void 0&&R.length>0&&R[0]===0)throw new Error(`${A} cannot have leading zeroes, received: ${R.toString("hex")}`)};e.validateNoLeadingZeroes=T;function P(t){return Array.isArray(t)?t.map(A=>P(A)):Buffer.from(t)}e.arrToBufArr=P;function d(t){return Array.isArray(t)?t.map(A=>d(A)):Uint8Array.from(t??[])}e.bufArrToArr=d;const m=t=>"0x"+t.toString(16);e.bigIntToHex=m;function s(t){return(0,e.unpadBuffer)(O(t))}e.bigIntToUnpaddedBuffer=s;function I(t){return(0,e.unpadBuffer)((0,e.intToBuffer)(t))}e.intToUnpaddedBuffer=I}(fe)),fe}var Le;function $e(){return Le||(Le=1,function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.accountBodyToRLP=e.accountBodyToSlim=e.accountBodyFromSlim=e.isZeroAddress=e.zeroAddress=e.importPublic=e.privateToAddress=e.privateToPublic=e.publicToAddress=e.pubToAddress=e.isValidPublic=e.isValidPrivate=e.generateAddress2=e.generateAddress=e.isValidChecksumAddress=e.toChecksumAddress=e.isValidAddress=e.Account=void 0;const c=Ge(),n=Ke(),y=ae(),a=Me(),r=z(),o=de(),f=le(),h=J(),_=BigInt(0);class b{constructor(I=_,t=_,A=o.KECCAK256_RLP,R=o.KECCAK256_NULL){this.nonce=I,this.balance=t,this.storageRoot=A,this.codeHash=R,this._validate()}static fromAccountData(I){const{nonce:t,balance:A,storageRoot:R,codeHash:j}=I;return new b(t!==void 0?(0,r.bufferToBigInt)((0,r.toBuffer)(t)):void 0,A!==void 0?(0,r.bufferToBigInt)((0,r.toBuffer)(A)):void 0,R!==void 0?(0,r.toBuffer)(R):void 0,j!==void 0?(0,r.toBuffer)(j):void 0)}static fromRlpSerializedAccount(I){const t=(0,r.arrToBufArr)(c.RLP.decode(Uint8Array.from(I)));if(!Array.isArray(t))throw new Error("Invalid serialized account input. Must be array");return this.fromValuesArray(t)}static fromValuesArray(I){const[t,A,R,j]=I;return new b((0,r.bufferToBigInt)(t),(0,r.bufferToBigInt)(A),R,j)}_validate(){if(this.nonce<_)throw new Error("nonce must be greater than zero");if(this.balance<_)throw new Error("balance must be greater than zero");if(this.storageRoot.length!==32)throw new Error("storageRoot must have a length of 32");if(this.codeHash.length!==32)throw new Error("codeHash must have a length of 32")}raw(){return[(0,r.bigIntToUnpaddedBuffer)(this.nonce),(0,r.bigIntToUnpaddedBuffer)(this.balance),this.storageRoot,this.codeHash]}serialize(){return Buffer.from(c.RLP.encode((0,r.bufArrToArr)(this.raw())))}isContract(){return!this.codeHash.equals(o.KECCAK256_NULL)}isEmpty(){return this.balance===_&&this.nonce===_&&this.codeHash.equals(o.KECCAK256_NULL)}}e.Account=b;const L=function(s){try{(0,f.assertIsString)(s)}catch{return!1}return/^0x[0-9a-fA-F]{40}$/.test(s)};e.isValidAddress=L;const v=function(s,I){(0,f.assertIsHexString)(s);const t=(0,h.stripHexPrefix)(s).toLowerCase();let A="";I!==void 0&&(A=(0,r.bufferToBigInt)((0,r.toBuffer)(I)).toString()+"0x");const R=Buffer.from(A+t,"utf8"),j=(0,a.bytesToHex)((0,n.keccak256)(R));let Q="0x";for(let V=0;V<t.length;V++)parseInt(j[V],16)>=8?Q+=t[V].toUpperCase():Q+=t[V];return Q};e.toChecksumAddress=v;const S=function(s,I){return(0,e.isValidAddress)(s)&&(0,e.toChecksumAddress)(s,I)===s};e.isValidChecksumAddress=S;const p=function(s,I){return(0,f.assertIsBuffer)(s),(0,f.assertIsBuffer)(I),(0,r.bufferToBigInt)(I)===BigInt(0)?Buffer.from((0,n.keccak256)(c.RLP.encode((0,r.bufArrToArr)([s,null])))).slice(-20):Buffer.from((0,n.keccak256)(c.RLP.encode((0,r.bufArrToArr)([s,I])))).slice(-20)};e.generateAddress=p;const k=function(s,I,t){if((0,f.assertIsBuffer)(s),(0,f.assertIsBuffer)(I),(0,f.assertIsBuffer)(t),s.length!==20)throw new Error("Expected from to be of length 20");if(I.length!==32)throw new Error("Expected salt to be of length 32");const A=(0,n.keccak256)(Buffer.concat([Buffer.from("ff","hex"),s,I,(0,n.keccak256)(t)]));return(0,r.toBuffer)(A).slice(-20)};e.generateAddress2=k;const O=function(s){return y.secp256k1.utils.isValidPrivateKey(s)};e.isValidPrivate=O;const u=function(s,I=!1){if((0,f.assertIsBuffer)(s),s.length===64)try{return y.secp256k1.ProjectivePoint.fromHex(Buffer.concat([Buffer.from([4]),s])),!0}catch{return!1}if(!I)return!1;try{return y.secp256k1.ProjectivePoint.fromHex(s),!0}catch{return!1}};e.isValidPublic=u;const g=function(s,I=!1){if((0,f.assertIsBuffer)(s),I&&s.length!==64&&(s=Buffer.from(y.secp256k1.ProjectivePoint.fromHex(s).toRawBytes(!1).slice(1))),s.length!==64)throw new Error("Expected pubKey to be of length 64");return Buffer.from((0,n.keccak256)(s)).slice(-20)};e.pubToAddress=g,e.publicToAddress=e.pubToAddress;const E=function(s){return(0,f.assertIsBuffer)(s),Buffer.from(y.secp256k1.ProjectivePoint.fromPrivateKey(s).toRawBytes(!1).slice(1))};e.privateToPublic=E;const B=function(s){return(0,e.publicToAddress)((0,e.privateToPublic)(s))};e.privateToAddress=B;const l=function(s){return(0,f.assertIsBuffer)(s),s.length!==64&&(s=Buffer.from(y.secp256k1.ProjectivePoint.fromHex(s).toRawBytes(!1).slice(1))),s};e.importPublic=l;const i=function(){const I=(0,r.zeros)(20);return(0,r.bufferToHex)(I)};e.zeroAddress=i;const w=function(s){try{(0,f.assertIsString)(s)}catch{return!1}return(0,e.zeroAddress)()===s};e.isZeroAddress=w;function T(s){const[I,t,A,R]=s;return[I,t,(0,r.arrToBufArr)(A).length===0?o.KECCAK256_RLP:A,(0,r.arrToBufArr)(R).length===0?o.KECCAK256_NULL:R]}e.accountBodyFromSlim=T;const P=new Uint8Array(0);function d(s){const[I,t,A,R]=s;return[I,t,(0,r.arrToBufArr)(A).equals(o.KECCAK256_RLP)?P:A,(0,r.arrToBufArr)(R).equals(o.KECCAK256_NULL)?P:R]}e.accountBodyToSlim=d;function m(s,I=!0){const t=I?T(s):s;return(0,r.arrToBufArr)(c.RLP.encode(t))}e.accountBodyToRLP=m}(ne)),ne}var x={},ke;function Ve(){if(ke)return x;ke=1,Object.defineProperty(x,"__esModule",{value:!0}),x.Address=void 0;const e=$e(),c=z();class n{constructor(a){if(a.length!==20)throw new Error("Invalid address length");this.buf=a}static zero(){return new n((0,c.zeros)(20))}static fromString(a){if(!(0,e.isValidAddress)(a))throw new Error("Invalid address");return new n((0,c.toBuffer)(a))}static fromPublicKey(a){if(!Buffer.isBuffer(a))throw new Error("Public key should be Buffer");const r=(0,e.pubToAddress)(a);return new n(r)}static fromPrivateKey(a){if(!Buffer.isBuffer(a))throw new Error("Private key should be Buffer");const r=(0,e.privateToAddress)(a);return new n(r)}static generate(a,r){if(typeof r!="bigint")throw new Error("Expected nonce to be a bigint");return new n((0,e.generateAddress)(a.buf,(0,c.bigIntToBuffer)(r)))}static generate2(a,r,o){if(!Buffer.isBuffer(r))throw new Error("Expected salt to be a Buffer");if(!Buffer.isBuffer(o))throw new Error("Expected initCode to be a Buffer");return new n((0,e.generateAddress2)(a.buf,r,o))}equals(a){return this.buf.equals(a.buf)}isZero(){return this.equals(n.zero())}isPrecompileOrSystemAddress(){const a=(0,c.bufferToBigInt)(this.buf),r=BigInt(0),o=BigInt("0xffff");return a>=r&&a<=o}toString(){return"0x"+this.buf.toString("hex")}toBuffer(){return Buffer.from(this.buf)}}return x.Address=n,x}var X={},ue={},Se;function De(){return Se||(Se=1,function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.toType=e.TypeOutput=void 0;const c=z(),n=J();var y;(function(r){r[r.Number=0]="Number",r[r.BigInt=1]="BigInt",r[r.Buffer=2]="Buffer",r[r.PrefixedHexString=3]="PrefixedHexString"})(y=e.TypeOutput||(e.TypeOutput={}));function a(r,o){if(r===null)return null;if(r===void 0)return;if(typeof r=="string"&&!(0,n.isHexString)(r))throw new Error(`A string must be provided with a 0x-prefix, given: ${r}`);if(typeof r=="number"&&!Number.isSafeInteger(r))throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");const f=(0,c.toBuffer)(r);switch(o){case y.Buffer:return f;case y.BigInt:return(0,c.bufferToBigInt)(f);case y.Number:{const h=(0,c.bufferToBigInt)(f);if(h>BigInt(Number.MAX_SAFE_INTEGER))throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");return Number(h)}case y.PrefixedHexString:return(0,c.bufferToHex)(f);default:throw new Error("unknown outputType")}}e.toType=a}(ue)),ue}var Re;function et(){if(Re)return X;Re=1,Object.defineProperty(X,"__esModule",{value:!0}),X.Withdrawal=void 0;const e=Ve(),c=z(),n=De();class y{constructor(r,o,f,h){this.index=r,this.validatorIndex=o,this.address=f,this.amount=h}static fromWithdrawalData(r){const{index:o,validatorIndex:f,address:h,amount:_}=r,b=(0,n.toType)(o,n.TypeOutput.BigInt),L=(0,n.toType)(f,n.TypeOutput.BigInt),v=new e.Address((0,n.toType)(h,n.TypeOutput.Buffer)),S=(0,n.toType)(_,n.TypeOutput.BigInt);return new y(b,L,v,S)}static fromValuesArray(r){if(r.length!==4)throw Error(`Invalid withdrawalArray length expected=4 actual=${r.length}`);const[o,f,h,_]=r;return y.fromWithdrawalData({index:o,validatorIndex:f,address:h,amount:_})}static toBufferArray(r){const{index:o,validatorIndex:f,address:h,amount:_}=r,b=(0,n.toType)(o,n.TypeOutput.BigInt)===BigInt(0)?Buffer.alloc(0):(0,n.toType)(o,n.TypeOutput.Buffer),L=(0,n.toType)(f,n.TypeOutput.BigInt)===BigInt(0)?Buffer.alloc(0):(0,n.toType)(f,n.TypeOutput.Buffer);let v;h instanceof e.Address?v=h.buf:v=(0,n.toType)(h,n.TypeOutput.Buffer);const S=(0,n.toType)(_,n.TypeOutput.BigInt)===BigInt(0)?Buffer.alloc(0):(0,n.toType)(_,n.TypeOutput.Buffer);return[b,L,v,S]}raw(){return y.toBufferArray(this)}toValue(){return{index:this.index,validatorIndex:this.validatorIndex,address:this.address.buf,amount:this.amount}}toJSON(){return{index:(0,c.bigIntToHex)(this.index),validatorIndex:(0,c.bigIntToHex)(this.validatorIndex),address:"0x"+this.address.buf.toString("hex"),amount:(0,c.bigIntToHex)(this.amount)}}}return X.Withdrawal=y,X}var U={},Oe;function tt(){if(Oe)return U;Oe=1,Object.defineProperty(U,"__esModule",{value:!0}),U.hashPersonalMessage=U.isValidSignature=U.fromRpcSig=U.toCompactSig=U.toRpcSig=U.ecrecover=U.ecsign=void 0;const e=Ke(),c=ae(),n=z(),y=de(),a=le();function r(p,k,O){const u=c.secp256k1.sign(p,k),g=u.toCompactRawBytes(),E=Buffer.from(g.slice(0,32)),B=Buffer.from(g.slice(32,64)),l=O===void 0?BigInt(u.recovery+27):BigInt(u.recovery+35)+BigInt(O)*BigInt(2);return{r:E,s:B,v:l}}U.ecsign=r;function o(p,k){return p===BigInt(0)||p===BigInt(1)?p:k===void 0?p-BigInt(27):p-(k*BigInt(2)+BigInt(35))}function f(p){return p===BigInt(0)||p===BigInt(1)}const h=function(p,k,O,u,g){const E=Buffer.concat([(0,n.setLengthLeft)(O,32),(0,n.setLengthLeft)(u,32)],64),B=o(k,g);if(!f(B))throw new Error("Invalid signature v value");const i=c.secp256k1.Signature.fromCompact(E).addRecoveryBit(Number(B)).recoverPublicKey(p);return Buffer.from(i.toRawBytes(!1).slice(1))};U.ecrecover=h;const _=function(p,k,O,u){const g=o(p,u);if(!f(g))throw new Error("Invalid signature v value");return(0,n.bufferToHex)(Buffer.concat([(0,n.setLengthLeft)(k,32),(0,n.setLengthLeft)(O,32),(0,n.toBuffer)(p)]))};U.toRpcSig=_;const b=function(p,k,O,u){const g=o(p,u);if(!f(g))throw new Error("Invalid signature v value");let E=O;return(p>BigInt(28)&&p%BigInt(2)===BigInt(1)||p===BigInt(1)||p===BigInt(28))&&(E=Buffer.from(O),E[0]|=128),(0,n.bufferToHex)(Buffer.concat([(0,n.setLengthLeft)(k,32),(0,n.setLengthLeft)(E,32)]))};U.toCompactSig=b;const L=function(p){const k=(0,n.toBuffer)(p);let O,u,g;if(k.length>=65)O=k.slice(0,32),u=k.slice(32,64),g=(0,n.bufferToBigInt)(k.slice(64));else if(k.length===64)O=k.slice(0,32),u=k.slice(32,64),g=BigInt((0,n.bufferToInt)(k.slice(32,33))>>7),u[0]&=127;else throw new Error("Invalid signature length");return g<27&&(g=g+BigInt(27)),{v:g,r:O,s:u}};U.fromRpcSig=L;const v=function(p,k,O,u=!0,g){if(k.length!==32||O.length!==32||!f(o(p,g)))return!1;const E=(0,n.bufferToBigInt)(k),B=(0,n.bufferToBigInt)(O);return!(E===BigInt(0)||E>=y.SECP256K1_ORDER||B===BigInt(0)||B>=y.SECP256K1_ORDER||u&&B>=y.SECP256K1_ORDER_DIV_2)};U.isValidSignature=v;const S=function(p){(0,a.assertIsBuffer)(p);const k=Buffer.from(`Ethereum Signed Message:
${p.length}`,"utf-8");return Buffer.from((0,e.keccak256)(Buffer.concat([k,p])))};return U.hashPersonalMessage=S,U}var se={},He;function rt(){return He||(He=1,function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.compactBytesToNibbles=e.bytesToNibbles=e.nibblesToCompactBytes=e.nibblesToBytes=e.hasTerminator=void 0;const c=o=>o.length>0&&o[o.length-1]===16;e.hasTerminator=c;const n=(o,f)=>{for(let h=0,_=0;_<o.length;h+=1,_+=2)f[h]=o[_]<<4|o[_+1]};e.nibblesToBytes=n;const y=o=>{let f=0;(0,e.hasTerminator)(o)&&(f=1,o=o.subarray(0,o.length-1));const h=new Uint8Array(o.length/2+1);return h[0]=f<<5,(o.length&1)===1&&(h[0]|=1<<4,h[0]|=o[0],o=o.subarray(1)),(0,e.nibblesToBytes)(o,h.subarray(1)),h};e.nibblesToCompactBytes=y;const a=o=>{const f=o.length*2+1,h=new Uint8Array(f);for(let _=0;_<o.length;_++){const b=o[_];h[_*2]=b/16,h[_*2+1]=b%16}return h[f-1]=16,h};e.bytesToNibbles=a;const r=o=>{if(o.length===0)return o;let f=(0,e.bytesToNibbles)(o);f[0]<2&&(f=f.subarray(0,f.length-1));const h=2-(f[0]&1);return f.subarray(h)};e.compactBytesToNibbles=r}(se)),se}var G={},Ce;function nt(){if(Ce)return G;Ce=1,Object.defineProperty(G,"__esModule",{value:!0}),G.AsyncEventEmitter=void 0;const e=Fe();async function c(y,a,r){let o;for await(const f of a)try{f.length<2?f.call(y,r):await new Promise((h,_)=>{f.call(y,r,b=>{b?_(b):h()})})}catch(h){o=h}if(o)throw o}class n extends e.EventEmitter{emit(a,...r){let[o,f]=r;const h=this;let _=h._events[a]??[];return f===void 0&&typeof o=="function"&&(f=o,o=void 0),(a==="newListener"||a==="removeListener")&&(o={event:o,fn:f},f=void 0),_=Array.isArray(_)?_:[_],c(h,_.slice(),o).then(f).catch(f),h.listenerCount(a)>0}once(a,r){const o=this;let f;if(typeof r!="function")throw new TypeError("listener must be a function");return r.length>=2?f=function(h,_){o.removeListener(a,f),r(h,_)}:f=function(h){o.removeListener(a,f),r(h,f)},o.on(a,f),o}first(a,r){let o=this._events[a]??[];if(typeof r!="function")throw new TypeError("listener must be a function");return Array.isArray(o)||(this._events[a]=o=[o]),o.unshift(r),this}before(a,r,o){return this.beforeOrAfter(a,r,o)}after(a,r,o){return this.beforeOrAfter(a,r,o,"after")}beforeOrAfter(a,r,o,f){let h=this._events[a]??[],_,b;const L=f==="after"?1:0;if(typeof o!="function")throw new TypeError("listener must be a function");if(typeof r!="function")throw new TypeError("target must be a function");for(Array.isArray(h)||(this._events[a]=h=[h]),b=h.length,_=h.length;_--;)if(h[_]===r){b=_+L;break}return h.splice(b,0,o),this}on(a,r){return super.on(a,r)}addListener(a,r){return super.addListener(a,r)}prependListener(a,r){return super.prependListener(a,r)}prependOnceListener(a,r){return super.prependOnceListener(a,r)}removeAllListeners(a){return super.removeAllListeners(a)}removeListener(a,r){return super.removeListener(a,r)}eventNames(){return super.eventNames()}listeners(a){return super.listeners(a)}listenerCount(a){return super.listenerCount(a)}getMaxListeners(){return super.getMaxListeners()}setMaxListeners(a){return super.setMaxListeners(a)}}return G.AsyncEventEmitter=n,G}var Y={},Ue;function it(){if(Ue)return Y;Ue=1,Object.defineProperty(Y,"__esModule",{value:!0}),Y.Lock=void 0;class e{constructor(){this.permits=1,this.promiseResolverQueue=[]}async acquire(){return this.permits>0?(this.permits-=1,Promise.resolve(!0)):new Promise(n=>this.promiseResolverQueue.push(n))}release(){if(this.permits+=1,this.permits>1&&this.promiseResolverQueue.length>0)console.warn("Lock.permits should never be > 0 when there is someone waiting.");else if(this.permits===1&&this.promiseResolverQueue.length>0){this.permits-=1;const n=this.promiseResolverQueue.shift();n&&n(!0)}}}return Y.Lock=e,Y}var $={},je;function ot(){if(je)return $;je=1,Object.defineProperty($,"__esModule",{value:!0}),$.getProvider=$.fetchFromProvider=void 0;const e=xe(),c=async(y,a)=>(await(0,e.default)(y,{headers:{"content-type":"application/json"},type:"json",data:{method:a.method,params:a.params,jsonrpc:"2.0",id:1}})).result;$.fetchFromProvider=c;const n=y=>{var a;if(typeof y=="string")return y;if(((a=y==null?void 0:y.connection)==null?void 0:a.url)!==void 0)return y.connection.url;throw new Error("Must provide valid provider URL or Web3Provider")};return $.getProvider=n,$}var qe;function lt(){return qe||(qe=1,function(e){var c=D&&D.__createBinding||(Object.create?function(a,r,o,f){f===void 0&&(f=o);var h=Object.getOwnPropertyDescriptor(r,o);(!h||("get"in h?!r.__esModule:h.writable||h.configurable))&&(h={enumerable:!0,get:function(){return r[o]}}),Object.defineProperty(a,f,h)}:function(a,r,o,f){f===void 0&&(f=o),a[f]=r[o]}),n=D&&D.__exportStar||function(a,r){for(var o in a)o!=="default"&&!Object.prototype.hasOwnProperty.call(r,o)&&c(r,a,o)};Object.defineProperty(e,"__esModule",{value:!0}),e.toAscii=e.stripHexPrefix=e.padToEven=e.isHexString=e.isHexPrefixed=e.getKeys=e.getBinarySize=e.fromUtf8=e.fromAscii=e.arrayContainsArray=void 0,n(de(),e),n(Xe(),e),n($e(),e),n(Ve(),e),n(et(),e),n(tt(),e),n(z(),e),n(De(),e),n(rt(),e),n(nt(),e);var y=J();Object.defineProperty(e,"arrayContainsArray",{enumerable:!0,get:function(){return y.arrayContainsArray}}),Object.defineProperty(e,"fromAscii",{enumerable:!0,get:function(){return y.fromAscii}}),Object.defineProperty(e,"fromUtf8",{enumerable:!0,get:function(){return y.fromUtf8}}),Object.defineProperty(e,"getBinarySize",{enumerable:!0,get:function(){return y.getBinarySize}}),Object.defineProperty(e,"getKeys",{enumerable:!0,get:function(){return y.getKeys}}),Object.defineProperty(e,"isHexPrefixed",{enumerable:!0,get:function(){return y.isHexPrefixed}}),Object.defineProperty(e,"isHexString",{enumerable:!0,get:function(){return y.isHexString}}),Object.defineProperty(e,"padToEven",{enumerable:!0,get:function(){return y.padToEven}}),Object.defineProperty(e,"stripHexPrefix",{enumerable:!0,get:function(){return y.stripHexPrefix}}),Object.defineProperty(e,"toAscii",{enumerable:!0,get:function(){return y.toAscii}}),n(it(),e),n(ot(),e)}(ee)),ee}export{he as a,at as b,D as c,dt as g,lt as r};
