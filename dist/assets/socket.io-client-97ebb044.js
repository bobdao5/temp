import{c as _}from"./@ethereumjs-ec0ac526.js";import{r as N}from"./engine.io-client-d6a25c93.js";import{r as T}from"./debug-6f842070.js";import{r as C}from"./socket.io-parser-e15d9aa2.js";import{r as x}from"./@socket.io-27564b7e.js";var E={},Q={get exports(){return E},set exports(d){E=d}},v={},q;function $(){if(q)return v;q=1;var d=_&&_.__importDefault||function(r){return r&&r.__esModule?r:{default:r}};Object.defineProperty(v,"__esModule",{value:!0}),v.url=void 0;const o=N(),p=d(T()).default("socket.io-client:url");function g(r,y="",f){let a=r;f=f||typeof location<"u"&&location,r==null&&(r=f.protocol+"//"+f.host),typeof r=="string"&&(r.charAt(0)==="/"&&(r.charAt(1)==="/"?r=f.protocol+r:r=f.host+r),/^(https?|wss?):\/\//.test(r)||(p("protocol-less url %s",r),typeof f<"u"?r=f.protocol+"//"+r:r="https://"+r),p("parse %s",r),a=o.parse(r)),a.port||(/^(http|ws)$/.test(a.protocol)?a.port="80":/^(http|ws)s$/.test(a.protocol)&&(a.port="443")),a.path=a.path||"/";const s=a.host.indexOf(":")!==-1?"["+a.host+"]":a.host;return a.id=a.protocol+"://"+s+":"+a.port+y,a.href=a.protocol+"://"+s+(f&&f.port===a.port?"":":"+a.port),a}return v.url=g,v}var O={},j={},w={},L;function F(){if(L)return w;L=1,Object.defineProperty(w,"__esModule",{value:!0}),w.on=void 0;function d(o,l,p){return o.on(l,p),function(){o.off(l,p)}}return w.on=d,w}var P;function z(){if(P)return j;P=1;var d=_&&_.__importDefault||function(a){return a&&a.__esModule?a:{default:a}};Object.defineProperty(j,"__esModule",{value:!0}),j.Socket=void 0;const o=C(),l=F(),p=x,r=d(T()).default("socket.io-client:socket"),y=Object.freeze({connect:1,connect_error:1,disconnect:1,disconnecting:1,newListener:1,removeListener:1});class f extends p.Emitter{constructor(e,s,n){super(),this.connected=!1,this.recovered=!1,this.receiveBuffer=[],this.sendBuffer=[],this._queue=[],this._queueSeq=0,this.ids=0,this.acks={},this.flags={},this.io=e,this.nsp=s,n&&n.auth&&(this.auth=n.auth),this._opts=Object.assign({},n),this.io._autoConnect&&this.open()}get disconnected(){return!this.connected}subEvents(){if(this.subs)return;const e=this.io;this.subs=[l.on(e,"open",this.onopen.bind(this)),l.on(e,"packet",this.onpacket.bind(this)),l.on(e,"error",this.onerror.bind(this)),l.on(e,"close",this.onclose.bind(this))]}get active(){return!!this.subs}connect(){return this.connected?this:(this.subEvents(),this.io._reconnecting||this.io.open(),this.io._readyState==="open"&&this.onopen(),this)}open(){return this.connect()}send(...e){return e.unshift("message"),this.emit.apply(this,e),this}emit(e,...s){if(y.hasOwnProperty(e))throw new Error('"'+e.toString()+'" is a reserved event name');if(s.unshift(e),this._opts.retries&&!this.flags.fromQueue&&!this.flags.volatile)return this._addToQueue(s),this;const n={type:o.PacketType.EVENT,data:s};if(n.options={},n.options.compress=this.flags.compress!==!1,typeof s[s.length-1]=="function"){const t=this.ids++;r("emitting packet with ack id %d",t);const i=s.pop();this._registerAckCallback(t,i),n.id=t}const u=this.io.engine&&this.io.engine.transport&&this.io.engine.transport.writable;return this.flags.volatile&&(!u||!this.connected)?r("discard packet as the transport is not currently writable"):this.connected?(this.notifyOutgoingListeners(n),this.packet(n)):this.sendBuffer.push(n),this.flags={},this}_registerAckCallback(e,s){var n;const u=(n=this.flags.timeout)!==null&&n!==void 0?n:this._opts.ackTimeout;if(u===void 0){this.acks[e]=s;return}const c=this.io.setTimeoutFn(()=>{delete this.acks[e];for(let t=0;t<this.sendBuffer.length;t++)this.sendBuffer[t].id===e&&(r("removing packet with ack id %d from the buffer",e),this.sendBuffer.splice(t,1));r("event with ack id %d has timed out after %d ms",e,u),s.call(this,new Error("operation has timed out"))},u);this.acks[e]=(...t)=>{this.io.clearTimeoutFn(c),s.apply(this,[null,...t])}}emitWithAck(e,...s){const n=this.flags.timeout!==void 0||this._opts.ackTimeout!==void 0;return new Promise((u,c)=>{s.push((t,i)=>n?t?c(t):u(i):u(t)),this.emit(e,...s)})}_addToQueue(e){let s;typeof e[e.length-1]=="function"&&(s=e.pop());const n={id:this._queueSeq++,tryCount:0,pending:!1,args:e,flags:Object.assign({fromQueue:!0},this.flags)};e.push((u,...c)=>n!==this._queue[0]?void 0:(u!==null?n.tryCount>this._opts.retries&&(r("packet [%d] is discarded after %d tries",n.id,n.tryCount),this._queue.shift(),s&&s(u)):(r("packet [%d] was successfully sent",n.id),this._queue.shift(),s&&s(null,...c)),n.pending=!1,this._drainQueue())),this._queue.push(n),this._drainQueue()}_drainQueue(e=!1){if(r("draining queue"),!this.connected||this._queue.length===0)return;const s=this._queue[0];if(s.pending&&!e){r("packet [%d] has already been sent and is waiting for an ack",s.id);return}s.pending=!0,s.tryCount++,r("sending packet [%d] (try nÂ°%d)",s.id,s.tryCount),this.flags=s.flags,this.emit.apply(this,s.args)}packet(e){e.nsp=this.nsp,this.io._packet(e)}onopen(){r("transport is open - connecting"),typeof this.auth=="function"?this.auth(e=>{this._sendConnectPacket(e)}):this._sendConnectPacket(this.auth)}_sendConnectPacket(e){this.packet({type:o.PacketType.CONNECT,data:this._pid?Object.assign({pid:this._pid,offset:this._lastOffset},e):e})}onerror(e){this.connected||this.emitReserved("connect_error",e)}onclose(e,s){r("close (%s)",e),this.connected=!1,delete this.id,this.emitReserved("disconnect",e,s)}onpacket(e){if(e.nsp===this.nsp)switch(e.type){case o.PacketType.CONNECT:e.data&&e.data.sid?this.onconnect(e.data.sid,e.data.pid):this.emitReserved("connect_error",new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));break;case o.PacketType.EVENT:case o.PacketType.BINARY_EVENT:this.onevent(e);break;case o.PacketType.ACK:case o.PacketType.BINARY_ACK:this.onack(e);break;case o.PacketType.DISCONNECT:this.ondisconnect();break;case o.PacketType.CONNECT_ERROR:this.destroy();const n=new Error(e.data.message);n.data=e.data.data,this.emitReserved("connect_error",n);break}}onevent(e){const s=e.data||[];r("emitting event %j",s),e.id!=null&&(r("attaching ack callback to event"),s.push(this.ack(e.id))),this.connected?this.emitEvent(s):this.receiveBuffer.push(Object.freeze(s))}emitEvent(e){if(this._anyListeners&&this._anyListeners.length){const s=this._anyListeners.slice();for(const n of s)n.apply(this,e)}super.emit.apply(this,e),this._pid&&e.length&&typeof e[e.length-1]=="string"&&(this._lastOffset=e[e.length-1])}ack(e){const s=this;let n=!1;return function(...u){n||(n=!0,r("sending ack %j",u),s.packet({type:o.PacketType.ACK,id:e,data:u}))}}onack(e){const s=this.acks[e.id];typeof s=="function"?(r("calling ack %s with %j",e.id,e.data),s.apply(this,e.data),delete this.acks[e.id]):r("bad ack %s",e.id)}onconnect(e,s){r("socket connected with id %s",e),this.id=e,this.recovered=s&&this._pid===s,this._pid=s,this.connected=!0,this.emitBuffered(),this.emitReserved("connect"),this._drainQueue(!0)}emitBuffered(){this.receiveBuffer.forEach(e=>this.emitEvent(e)),this.receiveBuffer=[],this.sendBuffer.forEach(e=>{this.notifyOutgoingListeners(e),this.packet(e)}),this.sendBuffer=[]}ondisconnect(){r("server disconnect (%s)",this.nsp),this.destroy(),this.onclose("io server disconnect")}destroy(){this.subs&&(this.subs.forEach(e=>e()),this.subs=void 0),this.io._destroy(this)}disconnect(){return this.connected&&(r("performing disconnect (%s)",this.nsp),this.packet({type:o.PacketType.DISCONNECT})),this.destroy(),this.connected&&this.onclose("io client disconnect"),this}close(){return this.disconnect()}compress(e){return this.flags.compress=e,this}get volatile(){return this.flags.volatile=!0,this}timeout(e){return this.flags.timeout=e,this}onAny(e){return this._anyListeners=this._anyListeners||[],this._anyListeners.push(e),this}prependAny(e){return this._anyListeners=this._anyListeners||[],this._anyListeners.unshift(e),this}offAny(e){if(!this._anyListeners)return this;if(e){const s=this._anyListeners;for(let n=0;n<s.length;n++)if(e===s[n])return s.splice(n,1),this}else this._anyListeners=[];return this}listenersAny(){return this._anyListeners||[]}onAnyOutgoing(e){return this._anyOutgoingListeners=this._anyOutgoingListeners||[],this._anyOutgoingListeners.push(e),this}prependAnyOutgoing(e){return this._anyOutgoingListeners=this._anyOutgoingListeners||[],this._anyOutgoingListeners.unshift(e),this}offAnyOutgoing(e){if(!this._anyOutgoingListeners)return this;if(e){const s=this._anyOutgoingListeners;for(let n=0;n<s.length;n++)if(e===s[n])return s.splice(n,1),this}else this._anyOutgoingListeners=[];return this}listenersAnyOutgoing(){return this._anyOutgoingListeners||[]}notifyOutgoingListeners(e){if(this._anyOutgoingListeners&&this._anyOutgoingListeners.length){const s=this._anyOutgoingListeners.slice();for(const n of s)n.apply(this,e.data)}}}return j.Socket=f,j}var M={},D;function I(){if(D)return M;D=1,Object.defineProperty(M,"__esModule",{value:!0}),M.Backoff=void 0;function d(o){o=o||{},this.ms=o.min||100,this.max=o.max||1e4,this.factor=o.factor||2,this.jitter=o.jitter>0&&o.jitter<=1?o.jitter:0,this.attempts=0}return M.Backoff=d,d.prototype.duration=function(){var o=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var l=Math.random(),p=Math.floor(l*this.jitter*o);o=Math.floor(l*10)&1?o+p:o-p}return Math.min(o,this.max)|0},d.prototype.reset=function(){this.attempts=0},d.prototype.setMin=function(o){this.ms=o},d.prototype.setMax=function(o){this.max=o},d.prototype.setJitter=function(o){this.jitter=o},M}var A;function V(){if(A)return O;A=1;var d=_&&_.__createBinding||(Object.create?function(c,t,i,h){h===void 0&&(h=i),Object.defineProperty(c,h,{enumerable:!0,get:function(){return t[i]}})}:function(c,t,i,h){h===void 0&&(h=i),c[h]=t[i]}),o=_&&_.__setModuleDefault||(Object.create?function(c,t){Object.defineProperty(c,"default",{enumerable:!0,value:t})}:function(c,t){c.default=t}),l=_&&_.__importStar||function(c){if(c&&c.__esModule)return c;var t={};if(c!=null)for(var i in c)i!=="default"&&Object.prototype.hasOwnProperty.call(c,i)&&d(t,c,i);return o(t,c),t},p=_&&_.__importDefault||function(c){return c&&c.__esModule?c:{default:c}};Object.defineProperty(O,"__esModule",{value:!0}),O.Manager=void 0;const g=N(),r=z(),y=l(C()),f=F(),a=I(),e=x,n=p(T()).default("socket.io-client:manager");class u extends e.Emitter{constructor(t,i){var h;super(),this.nsps={},this.subs=[],t&&typeof t=="object"&&(i=t,t=void 0),i=i||{},i.path=i.path||"/socket.io",this.opts=i,g.installTimerFunctions(this,i),this.reconnection(i.reconnection!==!1),this.reconnectionAttempts(i.reconnectionAttempts||1/0),this.reconnectionDelay(i.reconnectionDelay||1e3),this.reconnectionDelayMax(i.reconnectionDelayMax||5e3),this.randomizationFactor((h=i.randomizationFactor)!==null&&h!==void 0?h:.5),this.backoff=new a.Backoff({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()}),this.timeout(i.timeout==null?2e4:i.timeout),this._readyState="closed",this.uri=t;const m=i.parser||y;this.encoder=new m.Encoder,this.decoder=new m.Decoder,this._autoConnect=i.autoConnect!==!1,this._autoConnect&&this.open()}reconnection(t){return arguments.length?(this._reconnection=!!t,this):this._reconnection}reconnectionAttempts(t){return t===void 0?this._reconnectionAttempts:(this._reconnectionAttempts=t,this)}reconnectionDelay(t){var i;return t===void 0?this._reconnectionDelay:(this._reconnectionDelay=t,(i=this.backoff)===null||i===void 0||i.setMin(t),this)}randomizationFactor(t){var i;return t===void 0?this._randomizationFactor:(this._randomizationFactor=t,(i=this.backoff)===null||i===void 0||i.setJitter(t),this)}reconnectionDelayMax(t){var i;return t===void 0?this._reconnectionDelayMax:(this._reconnectionDelayMax=t,(i=this.backoff)===null||i===void 0||i.setMax(t),this)}timeout(t){return arguments.length?(this._timeout=t,this):this._timeout}maybeReconnectOnOpen(){!this._reconnecting&&this._reconnection&&this.backoff.attempts===0&&this.reconnect()}open(t){if(n("readyState %s",this._readyState),~this._readyState.indexOf("open"))return this;n("opening %s",this.uri),this.engine=new g.Socket(this.uri,this.opts);const i=this.engine,h=this;this._readyState="opening",this.skipReconnect=!1;const m=f.on(i,"open",function(){h.onopen(),t&&t()}),R=k=>{n("error"),this.cleanup(),this._readyState="closed",this.emitReserved("error",k),t?t(k):this.maybeReconnectOnOpen()},b=f.on(i,"error",R);if(this._timeout!==!1){const k=this._timeout;n("connect attempt will timeout after %d",k);const S=this.setTimeoutFn(()=>{n("connect attempt timed out after %d",k),m(),R(new Error("timeout")),i.close()},k);this.opts.autoUnref&&S.unref(),this.subs.push(()=>{this.clearTimeoutFn(S)})}return this.subs.push(m),this.subs.push(b),this}connect(t){return this.open(t)}onopen(){n("open"),this.cleanup(),this._readyState="open",this.emitReserved("open");const t=this.engine;this.subs.push(f.on(t,"ping",this.onping.bind(this)),f.on(t,"data",this.ondata.bind(this)),f.on(t,"error",this.onerror.bind(this)),f.on(t,"close",this.onclose.bind(this)),f.on(this.decoder,"decoded",this.ondecoded.bind(this)))}onping(){this.emitReserved("ping")}ondata(t){try{this.decoder.add(t)}catch(i){this.onclose("parse error",i)}}ondecoded(t){g.nextTick(()=>{this.emitReserved("packet",t)},this.setTimeoutFn)}onerror(t){n("error",t),this.emitReserved("error",t)}socket(t,i){let h=this.nsps[t];return h?this._autoConnect&&!h.active&&h.connect():(h=new r.Socket(this,t,i),this.nsps[t]=h),h}_destroy(t){const i=Object.keys(this.nsps);for(const h of i)if(this.nsps[h].active){n("socket %s is still active, skipping close",h);return}this._close()}_packet(t){n("writing packet %j",t);const i=this.encoder.encode(t);for(let h=0;h<i.length;h++)this.engine.write(i[h],t.options)}cleanup(){n("cleanup"),this.subs.forEach(t=>t()),this.subs.length=0,this.decoder.destroy()}_close(){n("disconnect"),this.skipReconnect=!0,this._reconnecting=!1,this.onclose("forced close"),this.engine&&this.engine.close()}disconnect(){return this._close()}onclose(t,i){n("closed due to %s",t),this.cleanup(),this.backoff.reset(),this._readyState="closed",this.emitReserved("close",t,i),this._reconnection&&!this.skipReconnect&&this.reconnect()}reconnect(){if(this._reconnecting||this.skipReconnect)return this;const t=this;if(this.backoff.attempts>=this._reconnectionAttempts)n("reconnect failed"),this.backoff.reset(),this.emitReserved("reconnect_failed"),this._reconnecting=!1;else{const i=this.backoff.duration();n("will wait %dms before reconnect attempt",i),this._reconnecting=!0;const h=this.setTimeoutFn(()=>{t.skipReconnect||(n("attempting reconnect"),this.emitReserved("reconnect_attempt",t.backoff.attempts),!t.skipReconnect&&t.open(m=>{m?(n("reconnect attempt error"),t._reconnecting=!1,t.reconnect(),this.emitReserved("reconnect_error",m)):(n("reconnect success"),t.onreconnect())}))},i);this.opts.autoUnref&&h.unref(),this.subs.push(()=>{this.clearTimeoutFn(h)})}}onreconnect(){const t=this.backoff.attempts;this._reconnecting=!1,this.backoff.reset(),this.emitReserved("reconnect",t)}}return O.Manager=u,O}var B;function G(){return B||(B=1,function(d,o){var l=_&&_.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(o,"__esModule",{value:!0}),o.default=o.connect=o.io=o.Socket=o.Manager=o.protocol=void 0;const p=$(),g=V();Object.defineProperty(o,"Manager",{enumerable:!0,get:function(){return g.Manager}});const r=z();Object.defineProperty(o,"Socket",{enumerable:!0,get:function(){return r.Socket}});const f=l(T()).default("socket.io-client"),a={};function e(n,u){typeof n=="object"&&(u=n,n=void 0),u=u||{};const c=p.url(n,u.path||"/socket.io"),t=c.source,i=c.id,h=c.path,m=a[i]&&h in a[i].nsps,R=u.forceNew||u["force new connection"]||u.multiplex===!1||m;let b;return R?(f("ignoring socket cache for %s",t),b=new g.Manager(t,u)):(a[i]||(f("new io instance for %s",t),a[i]=new g.Manager(t,u)),b=a[i]),c.query&&!u.query&&(u.query=c.queryKey),b.socket(c.path,u)}o.io=e,o.connect=e,o.default=e,Object.assign(e,{Manager:g.Manager,Socket:r.Socket,io:e,connect:e});var s=C();Object.defineProperty(o,"protocol",{enumerable:!0,get:function(){return s.protocol}}),d.exports=e}(Q,E)),E}export{G as r};
