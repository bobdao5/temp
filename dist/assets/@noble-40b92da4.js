var Tt={},lt={},Bt={},rt={},Ut;function zt(){if(Ut)return rt;Ut=1,Object.defineProperty(rt,"__esModule",{value:!0}),rt.output=rt.exists=rt.hash=rt.bytes=rt.bool=rt.number=void 0;function l(T){if(!Number.isSafeInteger(T)||T<0)throw new Error(`Wrong positive integer: ${T}`)}rt.number=l;function w(T){if(typeof T!="boolean")throw new Error(`Expected boolean, not ${T}`)}rt.bool=w;function I(T,...E){if(!(T instanceof Uint8Array))throw new Error("Expected Uint8Array");if(E.length>0&&!E.includes(T.length))throw new Error(`Expected Uint8Array of length ${E}, not of length=${T.length}`)}rt.bytes=I;function k(T){if(typeof T!="function"||typeof T.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");l(T.outputLen),l(T.blockLen)}rt.hash=k;function Y(T,E=!0){if(T.destroyed)throw new Error("Hash instance has been destroyed");if(E&&T.finished)throw new Error("Hash#digest() has already been called")}rt.exists=Y;function y(T,E){I(T);const N=E.outputLen;if(T.length<N)throw new Error(`digestInto() expects output buffer of length at least ${N}`)}rt.output=y;const b={number:l,bool:w,bytes:I,hash:k,exists:Y,output:y};return rt.default=b,rt}var At={},vt={},Ht;function Yt(){return Ht||(Ht=1,Object.defineProperty(vt,"__esModule",{value:!0}),vt.crypto=void 0,vt.crypto=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0),vt}var Rt;function xt(){return Rt||(Rt=1,function(l){/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */Object.defineProperty(l,"__esModule",{value:!0}),l.randomBytes=l.wrapXOFConstructorWithOpts=l.wrapConstructorWithOpts=l.wrapConstructor=l.checkOpts=l.Hash=l.concatBytes=l.toBytes=l.utf8ToBytes=l.asyncLoop=l.nextTick=l.hexToBytes=l.bytesToHex=l.isLE=l.rotr=l.createView=l.u32=l.u8=void 0;const w=Yt(),I=u=>u instanceof Uint8Array,k=u=>new Uint8Array(u.buffer,u.byteOffset,u.byteLength);l.u8=k;const Y=u=>new Uint32Array(u.buffer,u.byteOffset,Math.floor(u.byteLength/4));l.u32=Y;const y=u=>new DataView(u.buffer,u.byteOffset,u.byteLength);l.createView=y;const b=(u,h)=>u<<32-h|u>>>h;if(l.rotr=b,l.isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68,!l.isLE)throw new Error("Non little-endian hardware is not supported");const T=Array.from({length:256},(u,h)=>h.toString(16).padStart(2,"0"));function E(u){if(!I(u))throw new Error("Uint8Array expected");let h="";for(let H=0;H<u.length;H++)h+=T[u[H]];return h}l.bytesToHex=E;function N(u){if(typeof u!="string")throw new Error("hex string expected, got "+typeof u);const h=u.length;if(h%2)throw new Error("padded hex string expected, got unpadded hex of length "+h);const H=new Uint8Array(h/2);for(let R=0;R<H.length;R++){const i=R*2,e=u.slice(i,i+2),o=Number.parseInt(e,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");H[R]=o}return H}l.hexToBytes=N;const g=async()=>{};l.nextTick=g;async function O(u,h,H){let R=Date.now();for(let i=0;i<u;i++){H(i);const e=Date.now()-R;e>=0&&e<h||(await(0,l.nextTick)(),R+=e)}}l.asyncLoop=O;function $(u){if(typeof u!="string")throw new Error(`utf8ToBytes expected string, got ${typeof u}`);return new Uint8Array(new TextEncoder().encode(u))}l.utf8ToBytes=$;function m(u){if(typeof u=="string"&&(u=$(u)),!I(u))throw new Error(`expected Uint8Array, got ${typeof u}`);return u}l.toBytes=m;function _(...u){const h=new Uint8Array(u.reduce((R,i)=>R+i.length,0));let H=0;return u.forEach(R=>{if(!I(R))throw new Error("Uint8Array expected");h.set(R,H),H+=R.length}),h}l.concatBytes=_;class A{clone(){return this._cloneInto()}}l.Hash=A;const U=u=>Object.prototype.toString.call(u)==="[object Object]"&&u.constructor===Object;function Z(u,h){if(h!==void 0&&(typeof h!="object"||!U(h)))throw new Error("Options should be object or undefined");return Object.assign(u,h)}l.checkOpts=Z;function s(u){const h=R=>u().update(m(R)).digest(),H=u();return h.outputLen=H.outputLen,h.blockLen=H.blockLen,h.create=()=>u(),h}l.wrapConstructor=s;function d(u){const h=(R,i)=>u(i).update(m(R)).digest(),H=u({});return h.outputLen=H.outputLen,h.blockLen=H.blockLen,h.create=R=>u(R),h}l.wrapConstructorWithOpts=d;function t(u){const h=(R,i)=>u(i).update(m(R)).digest(),H=u({});return h.outputLen=H.outputLen,h.blockLen=H.blockLen,h.create=R=>u(R),h}l.wrapXOFConstructorWithOpts=t;function V(u=32){if(w.crypto&&typeof w.crypto.getRandomValues=="function")return w.crypto.getRandomValues(new Uint8Array(u));throw new Error("crypto.getRandomValues must be defined")}l.randomBytes=V}(At)),At}var Ct;function Gt(){if(Ct)return Bt;Ct=1,Object.defineProperty(Bt,"__esModule",{value:!0}),Bt.SHA2=void 0;const l=zt(),w=xt();function I(Y,y,b,T){if(typeof Y.setBigUint64=="function")return Y.setBigUint64(y,b,T);const E=BigInt(32),N=BigInt(4294967295),g=Number(b>>E&N),O=Number(b&N),$=T?4:0,m=T?0:4;Y.setUint32(y+$,g,T),Y.setUint32(y+m,O,T)}class k extends w.Hash{constructor(y,b,T,E){super(),this.blockLen=y,this.outputLen=b,this.padOffset=T,this.isLE=E,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(y),this.view=(0,w.createView)(this.buffer)}update(y){l.default.exists(this);const{view:b,buffer:T,blockLen:E}=this;y=(0,w.toBytes)(y);const N=y.length;for(let g=0;g<N;){const O=Math.min(E-this.pos,N-g);if(O===E){const $=(0,w.createView)(y);for(;E<=N-g;g+=E)this.process($,g);continue}T.set(y.subarray(g,g+O),this.pos),this.pos+=O,g+=O,this.pos===E&&(this.process(b,0),this.pos=0)}return this.length+=y.length,this.roundClean(),this}digestInto(y){l.default.exists(this),l.default.output(y,this),this.finished=!0;const{buffer:b,view:T,blockLen:E,isLE:N}=this;let{pos:g}=this;b[g++]=128,this.buffer.subarray(g).fill(0),this.padOffset>E-g&&(this.process(T,0),g=0);for(let A=g;A<E;A++)b[A]=0;I(T,E-8,BigInt(this.length*8),N),this.process(T,0);const O=(0,w.createView)(y),$=this.outputLen;if($%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const m=$/4,_=this.get();if(m>_.length)throw new Error("_sha2: outputLen bigger than state");for(let A=0;A<m;A++)O.setUint32(4*A,_[A],N)}digest(){const{buffer:y,outputLen:b}=this;this.digestInto(y);const T=y.slice(0,b);return this.destroy(),T}_cloneInto(y){y||(y=new this.constructor),y.set(...this.get());const{blockLen:b,buffer:T,length:E,finished:N,destroyed:g,pos:O}=this;return y.length=E,y.pos=O,y.finished=N,y.destroyed=g,E%b&&y.buffer.set(T),y}}return Bt.SHA2=k,Bt}var kt;function Xt(){if(kt)return lt;kt=1,Object.defineProperty(lt,"__esModule",{value:!0}),lt.sha224=lt.sha256=void 0;const l=Gt(),w=xt(),I=(N,g,O)=>N&g^~N&O,k=(N,g,O)=>N&g^N&O^g&O,Y=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),y=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),b=new Uint32Array(64);class T extends l.SHA2{constructor(){super(64,32,8,!1),this.A=y[0]|0,this.B=y[1]|0,this.C=y[2]|0,this.D=y[3]|0,this.E=y[4]|0,this.F=y[5]|0,this.G=y[6]|0,this.H=y[7]|0}get(){const{A:g,B:O,C:$,D:m,E:_,F:A,G:U,H:Z}=this;return[g,O,$,m,_,A,U,Z]}set(g,O,$,m,_,A,U,Z){this.A=g|0,this.B=O|0,this.C=$|0,this.D=m|0,this.E=_|0,this.F=A|0,this.G=U|0,this.H=Z|0}process(g,O){for(let t=0;t<16;t++,O+=4)b[t]=g.getUint32(O,!1);for(let t=16;t<64;t++){const V=b[t-15],u=b[t-2],h=(0,w.rotr)(V,7)^(0,w.rotr)(V,18)^V>>>3,H=(0,w.rotr)(u,17)^(0,w.rotr)(u,19)^u>>>10;b[t]=H+b[t-7]+h+b[t-16]|0}let{A:$,B:m,C:_,D:A,E:U,F:Z,G:s,H:d}=this;for(let t=0;t<64;t++){const V=(0,w.rotr)(U,6)^(0,w.rotr)(U,11)^(0,w.rotr)(U,25),u=d+V+I(U,Z,s)+Y[t]+b[t]|0,H=((0,w.rotr)($,2)^(0,w.rotr)($,13)^(0,w.rotr)($,22))+k($,m,_)|0;d=s,s=Z,Z=U,U=A+u|0,A=_,_=m,m=$,$=u+H|0}$=$+this.A|0,m=m+this.B|0,_=_+this.C|0,A=A+this.D|0,U=U+this.E|0,Z=Z+this.F|0,s=s+this.G|0,d=d+this.H|0,this.set($,m,_,A,U,Z,s,d)}roundClean(){b.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class E extends T{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}return lt.sha256=(0,w.wrapConstructor)(()=>new T),lt.sha224=(0,w.wrapConstructor)(()=>new E),lt}var G={},W={},jt;function pt(){if(jt)return W;jt=1,Object.defineProperty(W,"__esModule",{value:!0}),W.validateObject=W.createHmacDrbg=W.bitMask=W.bitSet=W.bitGet=W.bitLen=W.utf8ToBytes=W.equalBytes=W.concatBytes=W.ensureBytes=W.numberToVarBytesBE=W.numberToBytesLE=W.numberToBytesBE=W.bytesToNumberLE=W.bytesToNumberBE=W.hexToBytes=W.hexToNumber=W.numberToHexUnpadded=W.bytesToHex=void 0;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const l=BigInt(0),w=BigInt(1),I=BigInt(2),k=e=>e instanceof Uint8Array,Y=Array.from({length:256},(e,o)=>o.toString(16).padStart(2,"0"));function y(e){if(!k(e))throw new Error("Uint8Array expected");let o="";for(let c=0;c<e.length;c++)o+=Y[e[c]];return o}W.bytesToHex=y;function b(e){const o=e.toString(16);return o.length&1?`0${o}`:o}W.numberToHexUnpadded=b;function T(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return BigInt(e===""?"0":`0x${e}`)}W.hexToNumber=T;function E(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);const o=e.length;if(o%2)throw new Error("padded hex string expected, got unpadded hex of length "+o);const c=new Uint8Array(o/2);for(let v=0;v<c.length;v++){const L=v*2,S=e.slice(L,L+2),a=Number.parseInt(S,16);if(Number.isNaN(a)||a<0)throw new Error("Invalid byte sequence");c[v]=a}return c}W.hexToBytes=E;function N(e){return T(y(e))}W.bytesToNumberBE=N;function g(e){if(!k(e))throw new Error("Uint8Array expected");return T(y(Uint8Array.from(e).reverse()))}W.bytesToNumberLE=g;function O(e,o){return E(e.toString(16).padStart(o*2,"0"))}W.numberToBytesBE=O;function $(e,o){return O(e,o).reverse()}W.numberToBytesLE=$;function m(e){return E(b(e))}W.numberToVarBytesBE=m;function _(e,o,c){let v;if(typeof o=="string")try{v=E(o)}catch(S){throw new Error(`${e} must be valid hex string, got "${o}". Cause: ${S}`)}else if(k(o))v=Uint8Array.from(o);else throw new Error(`${e} must be hex string or Uint8Array`);const L=v.length;if(typeof c=="number"&&L!==c)throw new Error(`${e} expected ${c} bytes, got ${L}`);return v}W.ensureBytes=_;function A(...e){const o=new Uint8Array(e.reduce((v,L)=>v+L.length,0));let c=0;return e.forEach(v=>{if(!k(v))throw new Error("Uint8Array expected");o.set(v,c),c+=v.length}),o}W.concatBytes=A;function U(e,o){if(e.length!==o.length)return!1;for(let c=0;c<e.length;c++)if(e[c]!==o[c])return!1;return!0}W.equalBytes=U;function Z(e){if(typeof e!="string")throw new Error(`utf8ToBytes expected string, got ${typeof e}`);return new Uint8Array(new TextEncoder().encode(e))}W.utf8ToBytes=Z;function s(e){let o;for(o=0;e>l;e>>=w,o+=1);return o}W.bitLen=s;function d(e,o){return e>>BigInt(o)&w}W.bitGet=d;const t=(e,o,c)=>e|(c?w:l)<<BigInt(o);W.bitSet=t;const V=e=>(I<<BigInt(e-1))-w;W.bitMask=V;const u=e=>new Uint8Array(e),h=e=>Uint8Array.from(e);function H(e,o,c){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof o!="number"||o<2)throw new Error("qByteLen must be a number");if(typeof c!="function")throw new Error("hmacFn must be a function");let v=u(e),L=u(e),S=0;const a=()=>{v.fill(1),L.fill(0),S=0},r=(...B)=>c(L,v,...B),n=(B=u())=>{L=r(h([0]),B),v=r(),B.length!==0&&(L=r(h([1]),B),v=r())},f=()=>{if(S++>=1e3)throw new Error("drbg: tried 1000 values");let B=0;const P=[];for(;B<o;){v=r();const q=v.slice();P.push(q),B+=v.length}return A(...P)};return(B,P)=>{a(),n(B);let q;for(;!(q=P(f()));)n();return a(),q}}W.createHmacDrbg=H;const R={bigint:e=>typeof e=="bigint",function:e=>typeof e=="function",boolean:e=>typeof e=="boolean",string:e=>typeof e=="string",isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,o)=>o.Fp.isValid(e),hash:e=>typeof e=="function"&&Number.isSafeInteger(e.outputLen)};function i(e,o,c={}){const v=(L,S,a)=>{const r=R[S];if(typeof r!="function")throw new Error(`Invalid validator "${S}", expected function`);const n=e[L];if(!(a&&n===void 0)&&!r(n,e))throw new Error(`Invalid param ${String(L)}=${n} (${typeof n}), expected ${S}`)};for(const[L,S]of Object.entries(o))v(L,S,!1);for(const[L,S]of Object.entries(c))v(L,S,!0);return e}return W.validateObject=i,W}var Pt;function _t(){if(Pt)return G;Pt=1,Object.defineProperty(G,"__esModule",{value:!0}),G.hashToPrivateScalar=G.FpSqrtEven=G.FpSqrtOdd=G.Field=G.nLength=G.FpIsSquare=G.FpDiv=G.FpInvertBatch=G.FpPow=G.validateField=G.isNegativeLE=G.FpSqrt=G.tonelliShanks=G.invert=G.pow2=G.pow=G.mod=void 0;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const l=pt(),w=BigInt(0),I=BigInt(1),k=BigInt(2),Y=BigInt(3),y=BigInt(4),b=BigInt(5),T=BigInt(8);BigInt(9),BigInt(16);function E(i,e){const o=i%e;return o>=w?o:e+o}G.mod=E;function N(i,e,o){if(o<=w||e<w)throw new Error("Expected power/modulo > 0");if(o===I)return w;let c=I;for(;e>w;)e&I&&(c=c*i%o),i=i*i%o,e>>=I;return c}G.pow=N;function g(i,e,o){let c=i;for(;e-- >w;)c*=c,c%=o;return c}G.pow2=g;function O(i,e){if(i===w||e<=w)throw new Error(`invert: expected positive integers, got n=${i} mod=${e}`);let o=E(i,e),c=e,v=w,L=I;for(;o!==w;){const a=c/o,r=c%o,n=v-L*a;c=o,o=r,v=L,L=n}if(c!==I)throw new Error("invert: does not exist");return E(v,e)}G.invert=O;function $(i){const e=(i-I)/k;let o,c,v;for(o=i-I,c=0;o%k===w;o/=k,c++);for(v=k;v<i&&N(v,e,i)!==i-I;v++);if(c===1){const S=(i+I)/y;return function(r,n){const f=r.pow(n,S);if(!r.eql(r.sqr(f),n))throw new Error("Cannot find square root");return f}}const L=(o+I)/k;return function(a,r){if(a.pow(r,e)===a.neg(a.ONE))throw new Error("Cannot find square root");let n=c,f=a.pow(a.mul(a.ONE,v),o),p=a.pow(r,L),B=a.pow(r,o);for(;!a.eql(B,a.ONE);){if(a.eql(B,a.ZERO))return a.ZERO;let P=1;for(let j=a.sqr(B);P<n&&!a.eql(j,a.ONE);P++)j=a.sqr(j);const q=a.pow(f,I<<BigInt(n-P-1));f=a.sqr(q),p=a.mul(p,q),B=a.mul(B,f),n=P}return p}}G.tonelliShanks=$;function m(i){if(i%y===Y){const e=(i+I)/y;return function(c,v){const L=c.pow(v,e);if(!c.eql(c.sqr(L),v))throw new Error("Cannot find square root");return L}}if(i%T===b){const e=(i-b)/T;return function(c,v){const L=c.mul(v,k),S=c.pow(L,e),a=c.mul(v,S),r=c.mul(c.mul(a,k),S),n=c.mul(a,c.sub(r,c.ONE));if(!c.eql(c.sqr(n),v))throw new Error("Cannot find square root");return n}}return $(i)}G.FpSqrt=m;const _=(i,e)=>(E(i,e)&I)===I;G.isNegativeLE=_;const A=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function U(i){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},o=A.reduce((c,v)=>(c[v]="function",c),e);return(0,l.validateObject)(i,o)}G.validateField=U;function Z(i,e,o){if(o<w)throw new Error("Expected power > 0");if(o===w)return i.ONE;if(o===I)return e;let c=i.ONE,v=e;for(;o>w;)o&I&&(c=i.mul(c,v)),v=i.sqr(v),o>>=I;return c}G.FpPow=Z;function s(i,e){const o=new Array(e.length),c=e.reduce((L,S,a)=>i.is0(S)?L:(o[a]=L,i.mul(L,S)),i.ONE),v=i.inv(c);return e.reduceRight((L,S,a)=>i.is0(S)?L:(o[a]=i.mul(L,o[a]),i.mul(L,S)),v),o}G.FpInvertBatch=s;function d(i,e,o){return i.mul(e,typeof o=="bigint"?O(o,i.ORDER):i.inv(o))}G.FpDiv=d;function t(i){const e=(i.ORDER-I)/k;return o=>{const c=i.pow(o,e);return i.eql(c,i.ZERO)||i.eql(c,i.ONE)}}G.FpIsSquare=t;function V(i,e){const o=e!==void 0?e:i.toString(2).length,c=Math.ceil(o/8);return{nBitLength:o,nByteLength:c}}G.nLength=V;function u(i,e,o=!1,c={}){if(i<=w)throw new Error(`Expected Fp ORDER > 0, got ${i}`);const{nBitLength:v,nByteLength:L}=V(i,e);if(L>2048)throw new Error("Field lengths over 2048 bytes are not supported");const S=m(i),a=Object.freeze({ORDER:i,BITS:v,BYTES:L,MASK:(0,l.bitMask)(v),ZERO:w,ONE:I,create:r=>E(r,i),isValid:r=>{if(typeof r!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof r}`);return w<=r&&r<i},is0:r=>r===w,isOdd:r=>(r&I)===I,neg:r=>E(-r,i),eql:(r,n)=>r===n,sqr:r=>E(r*r,i),add:(r,n)=>E(r+n,i),sub:(r,n)=>E(r-n,i),mul:(r,n)=>E(r*n,i),pow:(r,n)=>Z(a,r,n),div:(r,n)=>E(r*O(n,i),i),sqrN:r=>r*r,addN:(r,n)=>r+n,subN:(r,n)=>r-n,mulN:(r,n)=>r*n,inv:r=>O(r,i),sqrt:c.sqrt||(r=>S(a,r)),invertBatch:r=>s(a,r),cmov:(r,n,f)=>f?n:r,toBytes:r=>o?(0,l.numberToBytesLE)(r,L):(0,l.numberToBytesBE)(r,L),fromBytes:r=>{if(r.length!==L)throw new Error(`Fp.fromBytes: expected ${L}, got ${r.length}`);return o?(0,l.bytesToNumberLE)(r):(0,l.bytesToNumberBE)(r)}});return Object.freeze(a)}G.Field=u;function h(i,e){if(!i.isOdd)throw new Error("Field doesn't have isOdd");const o=i.sqrt(e);return i.isOdd(o)?o:i.neg(o)}G.FpSqrtOdd=h;function H(i,e){if(!i.isOdd)throw new Error("Field doesn't have isOdd");const o=i.sqrt(e);return i.isOdd(o)?i.neg(o):o}G.FpSqrtEven=H;function R(i,e,o=!1){i=(0,l.ensureBytes)("privateHash",i);const c=i.length,v=V(e).nByteLength+8;if(v<24||c<v||c>1024)throw new Error(`hashToPrivateScalar: expected ${v}-1024 bytes of input, got ${c}`);const L=o?(0,l.bytesToNumberLE)(i):(0,l.bytesToNumberBE)(i);return E(L,e-I)+I}return G.hashToPrivateScalar=R,G}var Ot={},ht={},Vt;function Qt(){if(Vt)return ht;Vt=1,Object.defineProperty(ht,"__esModule",{value:!0}),ht.validateBasic=ht.wNAF=void 0;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const l=_t(),w=pt(),I=BigInt(0),k=BigInt(1);function Y(b,T){const E=(g,O)=>{const $=O.negate();return g?$:O},N=g=>{const O=Math.ceil(T/g)+1,$=2**(g-1);return{windows:O,windowSize:$}};return{constTimeNegate:E,unsafeLadder(g,O){let $=b.ZERO,m=g;for(;O>I;)O&k&&($=$.add(m)),m=m.double(),O>>=k;return $},precomputeWindow(g,O){const{windows:$,windowSize:m}=N(O),_=[];let A=g,U=A;for(let Z=0;Z<$;Z++){U=A,_.push(U);for(let s=1;s<m;s++)U=U.add(A),_.push(U);A=U.double()}return _},wNAF(g,O,$){const{windows:m,windowSize:_}=N(g);let A=b.ZERO,U=b.BASE;const Z=BigInt(2**g-1),s=2**g,d=BigInt(g);for(let t=0;t<m;t++){const V=t*_;let u=Number($&Z);$>>=d,u>_&&(u-=s,$+=k);const h=V,H=V+Math.abs(u)-1,R=t%2!==0,i=u<0;u===0?U=U.add(E(R,O[h])):A=A.add(E(i,O[H]))}return{p:A,f:U}},wNAFCached(g,O,$,m){const _=g._WINDOW_SIZE||1;let A=O.get(g);return A||(A=this.precomputeWindow(g,_),_!==1&&O.set(g,m(A))),this.wNAF(_,A,$)}}}ht.wNAF=Y;function y(b){return(0,l.validateField)(b.Fp),(0,w.validateObject)(b,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...(0,l.nLength)(b.n,b.nBitLength),...b,p:b.Fp.ORDER})}return ht.validateBasic=y,ht}var $t;function Kt(){return $t||($t=1,function(l){Object.defineProperty(l,"__esModule",{value:!0}),l.mapToCurveSimpleSWU=l.SWUFpSqrtRatio=l.weierstrass=l.weierstrassPoints=l.DER=void 0;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const w=_t(),I=pt(),k=pt(),Y=Qt();function y(s){const d=(0,Y.validateBasic)(s);I.validateObject(d,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:V,a:u}=d;if(t){if(!V.eql(u,V.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...d})}const{bytesToNumberBE:b,hexToBytes:T}=I;l.DER={Err:class extends Error{constructor(d=""){super(d)}},_parseInt(s){const{Err:d}=l.DER;if(s.length<2||s[0]!==2)throw new d("Invalid signature integer tag");const t=s[1],V=s.subarray(2,t+2);if(!t||V.length!==t)throw new d("Invalid signature integer: wrong length");if(V[0]&128)throw new d("Invalid signature integer: negative");if(V[0]===0&&!(V[1]&128))throw new d("Invalid signature integer: unnecessary leading zero");return{d:b(V),l:s.subarray(t+2)}},toSig(s){const{Err:d}=l.DER,t=typeof s=="string"?T(s):s;if(!(t instanceof Uint8Array))throw new Error("ui8a expected");let V=t.length;if(V<2||t[0]!=48)throw new d("Invalid signature tag");if(t[1]!==V-2)throw new d("Invalid signature: incorrect length");const{d:u,l:h}=l.DER._parseInt(t.subarray(2)),{d:H,l:R}=l.DER._parseInt(h);if(R.length)throw new d("Invalid signature: left bytes after parsing");return{r:u,s:H}},hexFromSig(s){const d=e=>Number.parseInt(e[0],16)&8?"00"+e:e,t=e=>{const o=e.toString(16);return o.length&1?`0${o}`:o},V=d(t(s.s)),u=d(t(s.r)),h=V.length/2,H=u.length/2,R=t(h),i=t(H);return`30${t(H+h+4)}02${i}${u}02${R}${V}`}};const E=BigInt(0),N=BigInt(1),g=BigInt(2),O=BigInt(3),$=BigInt(4);function m(s){const d=y(s),{Fp:t}=d,V=d.toBytes||((S,a,r)=>{const n=a.toAffine();return I.concatBytes(Uint8Array.from([4]),t.toBytes(n.x),t.toBytes(n.y))}),u=d.fromBytes||(S=>{const a=S.subarray(1),r=t.fromBytes(a.subarray(0,t.BYTES)),n=t.fromBytes(a.subarray(t.BYTES,2*t.BYTES));return{x:r,y:n}});function h(S){const{a,b:r}=d,n=t.sqr(S),f=t.mul(n,S);return t.add(t.add(f,t.mul(S,a)),r)}if(!t.eql(t.sqr(d.Gy),h(d.Gx)))throw new Error("bad generator point: equation left != right");function H(S){return typeof S=="bigint"&&E<S&&S<d.n}function R(S){if(!H(S))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function i(S){const{allowedPrivateKeyLengths:a,nByteLength:r,wrapPrivateKey:n,n:f}=d;if(a&&typeof S!="bigint"){if(S instanceof Uint8Array&&(S=I.bytesToHex(S)),typeof S!="string"||!a.includes(S.length))throw new Error("Invalid key");S=S.padStart(r*2,"0")}let p;try{p=typeof S=="bigint"?S:I.bytesToNumberBE((0,k.ensureBytes)("private key",S,r))}catch{throw new Error(`private key must be ${r} bytes, hex or bigint, not ${typeof S}`)}return n&&(p=w.mod(p,f)),R(p),p}const e=new Map;function o(S){if(!(S instanceof c))throw new Error("ProjectivePoint expected")}class c{constructor(a,r,n){if(this.px=a,this.py=r,this.pz=n,a==null||!t.isValid(a))throw new Error("x required");if(r==null||!t.isValid(r))throw new Error("y required");if(n==null||!t.isValid(n))throw new Error("z required")}static fromAffine(a){const{x:r,y:n}=a||{};if(!a||!t.isValid(r)||!t.isValid(n))throw new Error("invalid affine point");if(a instanceof c)throw new Error("projective point not allowed");const f=p=>t.eql(p,t.ZERO);return f(r)&&f(n)?c.ZERO:new c(r,n,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(a){const r=t.invertBatch(a.map(n=>n.pz));return a.map((n,f)=>n.toAffine(r[f])).map(c.fromAffine)}static fromHex(a){const r=c.fromAffine(u((0,k.ensureBytes)("pointHex",a)));return r.assertValidity(),r}static fromPrivateKey(a){return c.BASE.multiply(i(a))}_setWindowSize(a){this._WINDOW_SIZE=a,e.delete(this)}assertValidity(){if(this.is0()){if(d.allowInfinityPoint)return;throw new Error("bad point: ZERO")}const{x:a,y:r}=this.toAffine();if(!t.isValid(a)||!t.isValid(r))throw new Error("bad point: x or y not FE");const n=t.sqr(r),f=h(a);if(!t.eql(n,f))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:a}=this.toAffine();if(t.isOdd)return!t.isOdd(a);throw new Error("Field doesn't support isOdd")}equals(a){o(a);const{px:r,py:n,pz:f}=this,{px:p,py:B,pz:P}=a,q=t.eql(t.mul(r,P),t.mul(p,f)),j=t.eql(t.mul(n,P),t.mul(B,f));return q&&j}negate(){return new c(this.px,t.neg(this.py),this.pz)}double(){const{a,b:r}=d,n=t.mul(r,O),{px:f,py:p,pz:B}=this;let P=t.ZERO,q=t.ZERO,j=t.ZERO,M=t.mul(f,f),J=t.mul(p,p),z=t.mul(B,B),D=t.mul(f,p);return D=t.add(D,D),j=t.mul(f,B),j=t.add(j,j),P=t.mul(a,j),q=t.mul(n,z),q=t.add(P,q),P=t.sub(J,q),q=t.add(J,q),q=t.mul(P,q),P=t.mul(D,P),j=t.mul(n,j),z=t.mul(a,z),D=t.sub(M,z),D=t.mul(a,D),D=t.add(D,j),j=t.add(M,M),M=t.add(j,M),M=t.add(M,z),M=t.mul(M,D),q=t.add(q,M),z=t.mul(p,B),z=t.add(z,z),M=t.mul(z,D),P=t.sub(P,M),j=t.mul(z,J),j=t.add(j,j),j=t.add(j,j),new c(P,q,j)}add(a){o(a);const{px:r,py:n,pz:f}=this,{px:p,py:B,pz:P}=a;let q=t.ZERO,j=t.ZERO,M=t.ZERO;const J=d.a,z=t.mul(d.b,O);let D=t.mul(r,p),F=t.mul(n,B),tt=t.mul(f,P),nt=t.add(r,n),x=t.add(p,B);nt=t.mul(nt,x),x=t.add(D,F),nt=t.sub(nt,x),x=t.add(r,f);let C=t.add(p,P);return x=t.mul(x,C),C=t.add(D,tt),x=t.sub(x,C),C=t.add(n,f),q=t.add(B,P),C=t.mul(C,q),q=t.add(F,tt),C=t.sub(C,q),M=t.mul(J,x),q=t.mul(z,tt),M=t.add(q,M),q=t.sub(F,M),M=t.add(F,M),j=t.mul(q,M),F=t.add(D,D),F=t.add(F,D),tt=t.mul(J,tt),x=t.mul(z,x),F=t.add(F,tt),tt=t.sub(D,tt),tt=t.mul(J,tt),x=t.add(x,tt),D=t.mul(F,x),j=t.add(j,D),D=t.mul(C,x),q=t.mul(nt,q),q=t.sub(q,D),D=t.mul(nt,F),M=t.mul(C,M),M=t.add(M,D),new c(q,j,M)}subtract(a){return this.add(a.negate())}is0(){return this.equals(c.ZERO)}wNAF(a){return L.wNAFCached(this,e,a,r=>{const n=t.invertBatch(r.map(f=>f.pz));return r.map((f,p)=>f.toAffine(n[p])).map(c.fromAffine)})}multiplyUnsafe(a){const r=c.ZERO;if(a===E)return r;if(R(a),a===N)return this;const{endo:n}=d;if(!n)return L.unsafeLadder(this,a);let{k1neg:f,k1:p,k2neg:B,k2:P}=n.splitScalar(a),q=r,j=r,M=this;for(;p>E||P>E;)p&N&&(q=q.add(M)),P&N&&(j=j.add(M)),M=M.double(),p>>=N,P>>=N;return f&&(q=q.negate()),B&&(j=j.negate()),j=new c(t.mul(j.px,n.beta),j.py,j.pz),q.add(j)}multiply(a){R(a);let r=a,n,f;const{endo:p}=d;if(p){const{k1neg:B,k1:P,k2neg:q,k2:j}=p.splitScalar(r);let{p:M,f:J}=this.wNAF(P),{p:z,f:D}=this.wNAF(j);M=L.constTimeNegate(B,M),z=L.constTimeNegate(q,z),z=new c(t.mul(z.px,p.beta),z.py,z.pz),n=M.add(z),f=J.add(D)}else{const{p:B,f:P}=this.wNAF(r);n=B,f=P}return c.normalizeZ([n,f])[0]}multiplyAndAddUnsafe(a,r,n){const f=c.BASE,p=(P,q)=>q===E||q===N||!P.equals(f)?P.multiplyUnsafe(q):P.multiply(q),B=p(this,r).add(p(a,n));return B.is0()?void 0:B}toAffine(a){const{px:r,py:n,pz:f}=this,p=this.is0();a==null&&(a=p?t.ONE:t.inv(f));const B=t.mul(r,a),P=t.mul(n,a),q=t.mul(f,a);if(p)return{x:t.ZERO,y:t.ZERO};if(!t.eql(q,t.ONE))throw new Error("invZ was invalid");return{x:B,y:P}}isTorsionFree(){const{h:a,isTorsionFree:r}=d;if(a===N)return!0;if(r)return r(c,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:a,clearCofactor:r}=d;return a===N?this:r?r(c,this):this.multiplyUnsafe(d.h)}toRawBytes(a=!0){return this.assertValidity(),V(c,this,a)}toHex(a=!0){return I.bytesToHex(this.toRawBytes(a))}}c.BASE=new c(d.Gx,d.Gy,t.ONE),c.ZERO=new c(t.ZERO,t.ONE,t.ZERO);const v=d.nBitLength,L=(0,Y.wNAF)(c,d.endo?Math.ceil(v/2):v);return{CURVE:d,ProjectivePoint:c,normPrivateKeyToScalar:i,weierstrassEquation:h,isWithinCurveOrder:H}}l.weierstrassPoints=m;function _(s){const d=(0,Y.validateBasic)(s);return I.validateObject(d,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...d})}function A(s){const d=_(s),{Fp:t,n:V}=d,u=t.BYTES+1,h=2*t.BYTES+1;function H(x){return E<x&&x<t.ORDER}function R(x){return w.mod(x,V)}function i(x){return w.invert(x,V)}const{ProjectivePoint:e,normPrivateKeyToScalar:o,weierstrassEquation:c,isWithinCurveOrder:v}=m({...d,toBytes(x,C,K){const Q=C.toAffine(),X=t.toBytes(Q.x),et=I.concatBytes;return K?et(Uint8Array.from([C.hasEvenY()?2:3]),X):et(Uint8Array.from([4]),X,t.toBytes(Q.y))},fromBytes(x){const C=x.length,K=x[0],Q=x.subarray(1);if(C===u&&(K===2||K===3)){const X=I.bytesToNumberBE(Q);if(!H(X))throw new Error("Point is not on curve");const et=c(X);let ot=t.sqrt(et);const st=(ot&N)===N;return(K&1)===1!==st&&(ot=t.neg(ot)),{x:X,y:ot}}else if(C===h&&K===4){const X=t.fromBytes(Q.subarray(0,t.BYTES)),et=t.fromBytes(Q.subarray(t.BYTES,2*t.BYTES));return{x:X,y:et}}else throw new Error(`Point of length ${C} was invalid. Expected ${u} compressed bytes or ${h} uncompressed bytes`)}}),L=x=>I.bytesToHex(I.numberToBytesBE(x,d.nByteLength));function S(x){const C=V>>N;return x>C}function a(x){return S(x)?R(-x):x}const r=(x,C,K)=>I.bytesToNumberBE(x.slice(C,K));class n{constructor(C,K,Q){this.r=C,this.s=K,this.recovery=Q,this.assertValidity()}static fromCompact(C){const K=d.nByteLength;return C=(0,k.ensureBytes)("compactSignature",C,K*2),new n(r(C,0,K),r(C,K,2*K))}static fromDER(C){const{r:K,s:Q}=l.DER.toSig((0,k.ensureBytes)("DER",C));return new n(K,Q)}assertValidity(){if(!v(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!v(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(C){return new n(this.r,this.s,C)}recoverPublicKey(C){const{r:K,s:Q,recovery:X}=this,et=j((0,k.ensureBytes)("msgHash",C));if(X==null||![0,1,2,3].includes(X))throw new Error("recovery id invalid");const ot=X===2||X===3?K+d.n:K;if(ot>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const st=X&1?"03":"02",ct=e.fromHex(st+L(ot)),ft=i(ot),yt=R(-et*ft),Et=R(Q*ft),ut=e.BASE.multiplyAndAddUnsafe(ct,yt,Et);if(!ut)throw new Error("point at infinify");return ut.assertValidity(),ut}hasHighS(){return S(this.s)}normalizeS(){return this.hasHighS()?new n(this.r,R(-this.s),this.recovery):this}toDERRawBytes(){return I.hexToBytes(this.toDERHex())}toDERHex(){return l.DER.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return I.hexToBytes(this.toCompactHex())}toCompactHex(){return L(this.r)+L(this.s)}}const f={isValidPrivateKey(x){try{return o(x),!0}catch{return!1}},normPrivateKeyToScalar:o,randomPrivateKey:()=>{const x=d.randomBytes(t.BYTES+8),C=w.hashToPrivateScalar(x,V);return I.numberToBytesBE(C,d.nByteLength)},precompute(x=8,C=e.BASE){return C._setWindowSize(x),C.multiply(BigInt(3)),C}};function p(x,C=!0){return e.fromPrivateKey(x).toRawBytes(C)}function B(x){const C=x instanceof Uint8Array,K=typeof x=="string",Q=(C||K)&&x.length;return C?Q===u||Q===h:K?Q===2*u||Q===2*h:x instanceof e}function P(x,C,K=!0){if(B(x))throw new Error("first arg must be private key");if(!B(C))throw new Error("second arg must be public key");return e.fromHex(C).multiply(o(x)).toRawBytes(K)}const q=d.bits2int||function(x){const C=I.bytesToNumberBE(x),K=x.length*8-d.nBitLength;return K>0?C>>BigInt(K):C},j=d.bits2int_modN||function(x){return R(q(x))},M=I.bitMask(d.nBitLength);function J(x){if(typeof x!="bigint")throw new Error("bigint expected");if(!(E<=x&&x<M))throw new Error(`bigint expected < 2^${d.nBitLength}`);return I.numberToBytesBE(x,d.nByteLength)}function z(x,C,K=D){if(["recovered","canonical"].some(dt=>dt in K))throw new Error("sign() legacy options not supported");const{hash:Q,randomBytes:X}=d;let{lowS:et,prehash:ot,extraEntropy:st}=K;et==null&&(et=!0),x=(0,k.ensureBytes)("msgHash",x),ot&&(x=(0,k.ensureBytes)("prehashed msgHash",Q(x)));const ct=j(x),ft=o(C),yt=[J(ft),J(ct)];if(st!=null){const dt=st===!0?X(t.BYTES):st;yt.push((0,k.ensureBytes)("extraEntropy",dt,t.BYTES))}const Et=I.concatBytes(...yt),ut=ct;function St(dt){const wt=q(dt);if(!v(wt))return;const qt=i(wt),gt=e.BASE.multiply(wt).toAffine(),at=R(gt.x);if(at===E)return;const mt=R(qt*R(ut+at*ft));if(mt===E)return;let Nt=(gt.x===at?0:2)|Number(gt.y&N),Lt=mt;return et&&S(mt)&&(Lt=a(mt),Nt^=1),new n(at,Lt,Nt)}return{seed:Et,k2sig:St}}const D={lowS:d.lowS,prehash:!1},F={lowS:d.lowS,prehash:!1};function tt(x,C,K=D){const{seed:Q,k2sig:X}=z(x,C,K),et=d;return I.createHmacDrbg(et.hash.outputLen,et.nByteLength,et.hmac)(Q,X)}e.BASE._setWindowSize(8);function nt(x,C,K,Q=F){var gt;const X=x;if(C=(0,k.ensureBytes)("msgHash",C),K=(0,k.ensureBytes)("publicKey",K),"strict"in Q)throw new Error("options.strict was renamed to lowS");const{lowS:et,prehash:ot}=Q;let st,ct;try{if(typeof X=="string"||X instanceof Uint8Array)try{st=n.fromDER(X)}catch(at){if(!(at instanceof l.DER.Err))throw at;st=n.fromCompact(X)}else if(typeof X=="object"&&typeof X.r=="bigint"&&typeof X.s=="bigint"){const{r:at,s:mt}=X;st=new n(at,mt)}else throw new Error("PARSE");ct=e.fromHex(K)}catch(at){if(at.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(et&&st.hasHighS())return!1;ot&&(C=d.hash(C));const{r:ft,s:yt}=st,Et=j(C),ut=i(yt),St=R(Et*ut),dt=R(ft*ut),wt=(gt=e.BASE.multiplyAndAddUnsafe(ct,St,dt))==null?void 0:gt.toAffine();return wt?R(wt.x)===ft:!1}return{CURVE:d,getPublicKey:p,getSharedSecret:P,sign:tt,verify:nt,ProjectivePoint:e,Signature:n,utils:f}}l.weierstrass=A;function U(s,d){const t=s.ORDER;let V=E;for(let S=t-N;S%g===E;S/=g)V+=N;const u=V,h=g<<u-N-N,H=h*g,R=(t-N)/H,i=(R-N)/g,e=H-N,o=h,c=s.pow(d,R),v=s.pow(d,(R+N)/g);let L=(S,a)=>{let r=c,n=s.pow(a,e),f=s.sqr(n);f=s.mul(f,a);let p=s.mul(S,f);p=s.pow(p,i),p=s.mul(p,n),n=s.mul(p,a),f=s.mul(p,S);let B=s.mul(f,n);p=s.pow(B,o);let P=s.eql(p,s.ONE);n=s.mul(f,v),p=s.mul(B,r),f=s.cmov(n,f,P),B=s.cmov(p,B,P);for(let q=u;q>N;q--){let j=q-g;j=g<<j-N;let M=s.pow(B,j);const J=s.eql(M,s.ONE);n=s.mul(f,r),r=s.mul(r,r),M=s.mul(B,r),f=s.cmov(n,f,J),B=s.cmov(M,B,J)}return{isValid:P,value:f}};if(s.ORDER%$===O){const S=(s.ORDER-O)/$,a=s.sqrt(s.neg(d));L=(r,n)=>{let f=s.sqr(n);const p=s.mul(r,n);f=s.mul(f,p);let B=s.pow(f,S);B=s.mul(B,p);const P=s.mul(B,a),q=s.mul(s.sqr(B),n),j=s.eql(q,r);let M=s.cmov(P,B,j);return{isValid:j,value:M}}}return L}l.SWUFpSqrtRatio=U;function Z(s,d){if(w.validateField(s),!s.isValid(d.A)||!s.isValid(d.B)||!s.isValid(d.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const t=U(s,d.Z);if(!s.isOdd)throw new Error("Fp.isOdd is not implemented!");return V=>{let u,h,H,R,i,e,o,c;u=s.sqr(V),u=s.mul(u,d.Z),h=s.sqr(u),h=s.add(h,u),H=s.add(h,s.ONE),H=s.mul(H,d.B),R=s.cmov(d.Z,s.neg(h),!s.eql(h,s.ZERO)),R=s.mul(R,d.A),h=s.sqr(H),e=s.sqr(R),i=s.mul(e,d.A),h=s.add(h,i),h=s.mul(h,H),e=s.mul(e,R),i=s.mul(e,d.B),h=s.add(h,i),o=s.mul(u,H);const{isValid:v,value:L}=t(h,e);c=s.mul(u,V),c=s.mul(c,L),o=s.cmov(o,H,v),c=s.cmov(c,L,v);const S=s.isOdd(V)===s.isOdd(c);return c=s.cmov(s.neg(c),c,S),o=s.div(o,R),{x:o,y:c}}}l.mapToCurveSimpleSWU=Z}(Ot)),Ot}var it={},Mt;function Jt(){if(Mt)return it;Mt=1,Object.defineProperty(it,"__esModule",{value:!0}),it.createHasher=it.isogenyMap=it.hash_to_field=it.expand_message_xof=it.expand_message_xmd=void 0;const l=_t(),w=pt();function I(m){if(m instanceof Uint8Array)return m;if(typeof m=="string")return(0,w.utf8ToBytes)(m);throw new Error("DST must be Uint8Array or string")}const k=w.bytesToNumberBE;function Y(m,_){if(m<0||m>=1<<8*_)throw new Error(`bad I2OSP call: value=${m} length=${_}`);const A=Array.from({length:_}).fill(0);for(let U=_-1;U>=0;U--)A[U]=m&255,m>>>=8;return new Uint8Array(A)}function y(m,_){const A=new Uint8Array(m.length);for(let U=0;U<m.length;U++)A[U]=m[U]^_[U];return A}function b(m){if(!(m instanceof Uint8Array))throw new Error("Uint8Array expected")}function T(m){if(!Number.isSafeInteger(m))throw new Error("number expected")}function E(m,_,A,U){b(m),b(_),T(A),_.length>255&&(_=U((0,w.concatBytes)((0,w.utf8ToBytes)("H2C-OVERSIZE-DST-"),_)));const{outputLen:Z,blockLen:s}=U,d=Math.ceil(A/Z);if(d>255)throw new Error("Invalid xmd length");const t=(0,w.concatBytes)(_,Y(_.length,1)),V=Y(0,s),u=Y(A,2),h=new Array(d),H=U((0,w.concatBytes)(V,m,u,Y(0,1),t));h[0]=U((0,w.concatBytes)(H,Y(1,1),t));for(let i=1;i<=d;i++){const e=[y(H,h[i-1]),Y(i+1,1),t];h[i]=U((0,w.concatBytes)(...e))}return(0,w.concatBytes)(...h).slice(0,A)}it.expand_message_xmd=E;function N(m,_,A,U,Z){if(b(m),b(_),T(A),_.length>255){const s=Math.ceil(2*U/8);_=Z.create({dkLen:s}).update((0,w.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(_).digest()}if(A>65535||_.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return Z.create({dkLen:A}).update(m).update(Y(A,2)).update(_).update(Y(_.length,1)).digest()}it.expand_message_xof=N;function g(m,_,A){(0,w.validateObject)(A,{DST:"string",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:U,k:Z,m:s,hash:d,expand:t,DST:V}=A;b(m),T(_);const u=I(V),h=U.toString(2).length,H=Math.ceil((h+Z)/8),R=_*s*H;let i;if(t==="xmd")i=E(m,u,R,d);else if(t==="xof")i=N(m,u,R,Z,d);else if(t==="_internal_pass")i=m;else throw new Error('expand must be "xmd" or "xof"');const e=new Array(_);for(let o=0;o<_;o++){const c=new Array(s);for(let v=0;v<s;v++){const L=H*(v+o*s),S=i.subarray(L,L+H);c[v]=(0,l.mod)(k(S),U)}e[o]=c}return e}it.hash_to_field=g;function O(m,_){const A=_.map(U=>Array.from(U).reverse());return(U,Z)=>{const[s,d,t,V]=A.map(u=>u.reduce((h,H)=>m.add(m.mul(h,U),H)));return U=m.div(s,d),Z=m.mul(Z,m.div(t,V)),{x:U,y:Z}}}it.isogenyMap=O;function $(m,_,A){if(typeof _!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(U,Z){const s=g(U,2,{...A,DST:A.DST,...Z}),d=m.fromAffine(_(s[0])),t=m.fromAffine(_(s[1])),V=d.add(t).clearCofactor();return V.assertValidity(),V},encodeToCurve(U,Z){const s=g(U,1,{...A,DST:A.encodeDST,...Z}),d=m.fromAffine(_(s[0])).clearCofactor();return d.assertValidity(),d}}}return it.createHasher=$,it}var bt={},It={},Dt;function Ft(){return Dt||(Dt=1,function(l){Object.defineProperty(l,"__esModule",{value:!0}),l.hmac=l.HMAC=void 0;const w=zt(),I=xt();class k extends I.Hash{constructor(b,T){super(),this.finished=!1,this.destroyed=!1,w.default.hash(b);const E=(0,I.toBytes)(T);if(this.iHash=b.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const N=this.blockLen,g=new Uint8Array(N);g.set(E.length>N?b.create().update(E).digest():E);for(let O=0;O<g.length;O++)g[O]^=54;this.iHash.update(g),this.oHash=b.create();for(let O=0;O<g.length;O++)g[O]^=106;this.oHash.update(g),g.fill(0)}update(b){return w.default.exists(this),this.iHash.update(b),this}digestInto(b){w.default.exists(this),w.default.bytes(b,this.outputLen),this.finished=!0,this.iHash.digestInto(b),this.oHash.update(b),this.oHash.digestInto(b),this.destroy()}digest(){const b=new Uint8Array(this.oHash.outputLen);return this.digestInto(b),b}_cloneInto(b){b||(b=Object.create(Object.getPrototypeOf(this),{}));const{oHash:T,iHash:E,finished:N,destroyed:g,blockLen:O,outputLen:$}=this;return b=b,b.finished=N,b.destroyed=g,b.blockLen=O,b.outputLen=$,b.oHash=T._cloneInto(b.oHash),b.iHash=E._cloneInto(b.iHash),b}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}l.HMAC=k;const Y=(y,b,T)=>new k(y,b).update(T).digest();l.hmac=Y,l.hmac.create=(y,b)=>new k(y,b)}(It)),It}var Zt;function te(){if(Zt)return bt;Zt=1,Object.defineProperty(bt,"__esModule",{value:!0}),bt.createCurve=bt.getHash=void 0;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const l=Ft(),w=xt(),I=Kt();function k(y){return{hash:y,hmac:(b,...T)=>(0,l.hmac)(y,b,(0,w.concatBytes)(...T)),randomBytes:w.randomBytes}}bt.getHash=k;function Y(y,b){const T=E=>(0,I.weierstrass)({...y,...k(E)});return Object.freeze({...T(b),create:T})}return bt.createCurve=Y,bt}var Wt;function ne(){return Wt||(Wt=1,function(l){Object.defineProperty(l,"__esModule",{value:!0}),l.encodeToCurve=l.hashToCurve=l.schnorr=l.secp256k1=void 0;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const w=Xt(),I=xt(),k=_t(),Y=Kt(),y=pt(),b=Jt(),T=te(),E=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),N=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),g=BigInt(1),O=BigInt(2),$=(n,f)=>(n+f/O)/f;function m(n){const f=E,p=BigInt(3),B=BigInt(6),P=BigInt(11),q=BigInt(22),j=BigInt(23),M=BigInt(44),J=BigInt(88),z=n*n*n%f,D=z*z*n%f,F=(0,k.pow2)(D,p,f)*D%f,tt=(0,k.pow2)(F,p,f)*D%f,nt=(0,k.pow2)(tt,O,f)*z%f,x=(0,k.pow2)(nt,P,f)*nt%f,C=(0,k.pow2)(x,q,f)*x%f,K=(0,k.pow2)(C,M,f)*C%f,Q=(0,k.pow2)(K,J,f)*K%f,X=(0,k.pow2)(Q,M,f)*C%f,et=(0,k.pow2)(X,p,f)*D%f,ot=(0,k.pow2)(et,j,f)*x%f,st=(0,k.pow2)(ot,B,f)*z%f,ct=(0,k.pow2)(st,O,f);if(!_.eql(_.sqr(ct),n))throw new Error("Cannot find square root");return ct}const _=(0,k.Field)(E,void 0,void 0,{sqrt:m});l.secp256k1=(0,T.createCurve)({a:BigInt(0),b:BigInt(7),Fp:_,n:N,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:n=>{const f=N,p=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),B=-g*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),P=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),q=p,j=BigInt("0x100000000000000000000000000000000"),M=$(q*n,f),J=$(-B*n,f);let z=(0,k.mod)(n-M*p-J*P,f),D=(0,k.mod)(-M*B-J*q,f);const F=z>j,tt=D>j;if(F&&(z=f-z),tt&&(D=f-D),z>j||D>j)throw new Error("splitScalar: Endomorphism failed, k="+n);return{k1neg:F,k1:z,k2neg:tt,k2:D}}}},w.sha256);const A=BigInt(0),U=n=>typeof n=="bigint"&&A<n&&n<E,Z=n=>typeof n=="bigint"&&A<n&&n<N,s={};function d(n,...f){let p=s[n];if(p===void 0){const B=(0,w.sha256)(Uint8Array.from(n,P=>P.charCodeAt(0)));p=(0,y.concatBytes)(B,B),s[n]=p}return(0,w.sha256)((0,y.concatBytes)(p,...f))}const t=n=>n.toRawBytes(!0).slice(1),V=n=>(0,y.numberToBytesBE)(n,32),u=n=>(0,k.mod)(n,E),h=n=>(0,k.mod)(n,N),H=l.secp256k1.ProjectivePoint,R=(n,f,p)=>H.BASE.multiplyAndAddUnsafe(n,f,p);function i(n){let f=l.secp256k1.utils.normPrivateKeyToScalar(n),p=H.fromPrivateKey(f);return{scalar:p.hasEvenY()?f:h(-f),bytes:t(p)}}function e(n){if(!U(n))throw new Error("bad x: need 0 < x < p");const f=u(n*n),p=u(f*n+BigInt(7));let B=m(p);B%O!==A&&(B=u(-B));const P=new H(n,B,g);return P.assertValidity(),P}function o(...n){return h((0,y.bytesToNumberBE)(d("BIP0340/challenge",...n)))}function c(n){return i(n).bytes}function v(n,f,p=(0,I.randomBytes)(32)){const B=(0,y.ensureBytes)("message",n),{bytes:P,scalar:q}=i(f),j=(0,y.ensureBytes)("auxRand",p,32),M=V(q^(0,y.bytesToNumberBE)(d("BIP0340/aux",j))),J=d("BIP0340/nonce",M,P,B),z=h((0,y.bytesToNumberBE)(J));if(z===A)throw new Error("sign failed: k is zero");const{bytes:D,scalar:F}=i(z),tt=o(D,P,B),nt=new Uint8Array(64);if(nt.set(D,0),nt.set(V(h(F+tt*q)),32),!L(nt,B,P))throw new Error("sign: Invalid signature produced");return nt}function L(n,f,p){const B=(0,y.ensureBytes)("signature",n,64),P=(0,y.ensureBytes)("message",f),q=(0,y.ensureBytes)("publicKey",p,32);try{const j=e((0,y.bytesToNumberBE)(q)),M=(0,y.bytesToNumberBE)(B.subarray(0,32));if(!U(M))return!1;const J=(0,y.bytesToNumberBE)(B.subarray(32,64));if(!Z(J))return!1;const z=o(V(M),t(j),P),D=R(j,J,h(-z));return!(!D||!D.hasEvenY()||D.toAffine().x!==M)}catch{return!1}}l.schnorr=(()=>({getPublicKey:c,sign:v,verify:L,utils:{randomPrivateKey:l.secp256k1.utils.randomPrivateKey,lift_x:e,pointToBytes:t,numberToBytesBE:y.numberToBytesBE,bytesToNumberBE:y.bytesToNumberBE,taggedHash:d,mod:k.mod}}))();const S=(()=>(0,b.isogenyMap)(_,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(n=>n.map(f=>BigInt(f)))))(),a=(()=>(0,Y.mapToCurveSimpleSWU)(_,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:_.create(BigInt("-11"))}))(),r=(()=>(0,b.createHasher)(l.secp256k1.ProjectivePoint,n=>{const{x:f,y:p}=a(_.create(n[0]));return S(f,p)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:_.ORDER,m:1,k:128,expand:"xmd",hash:w.sha256}))();l.hashToCurve=(()=>r.hashToCurve)(),l.encodeToCurve=(()=>r.encodeToCurve)()}(Tt)),Tt}export{ne as r};
