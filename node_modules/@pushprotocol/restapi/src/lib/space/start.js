"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.start = void 0;
const tslib_1 = require("tslib");
const types_1 = require("../types");
const helpers_1 = require("./../chat/helpers");
const get_1 = require("./get");
const updateGroup_1 = require("../chat/updateGroup");
const getMergeStreamObject_1 = require("./helpers/getMergeStreamObject");
const axios_1 = require("axios");
const webrtmp_sdk_1 = require("@livepeer/webrtmp-sdk");
const immer_1 = require("immer");
function start(options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { livepeerApiKey } = options || {};
        try {
            // TODO: Only allow the host to execute this function
            // host should have there audio stream
            if (!this.data.local.stream) {
                throw new Error('Local audio stream not found');
            }
            const space = yield (0, get_1.get)({
                spaceId: this.spaceSpecificData.spaceId,
                env: this.env,
            });
            if (space.status !== types_1.ChatStatus.PENDING) {
                throw new Error('Unable to start the space as it is not in the pending state');
            }
            const convertedMembers = (0, helpers_1.getSpacesMembersList)(space.members, space.pendingMembers);
            const convertedAdmins = (0, helpers_1.getSpaceAdminsList)(space.members, space.pendingMembers);
            const group = yield (0, updateGroup_1.updateGroup)({
                chatId: this.spaceSpecificData.spaceId,
                groupName: space.spaceName,
                groupImage: space.spaceImage,
                groupDescription: space.spaceDescription,
                members: convertedMembers,
                admins: convertedAdmins,
                signer: this.signer,
                env: this.env,
                pgpPrivateKey: this.pgpPrivateKey,
                scheduleAt: space.scheduleAt,
                scheduleEnd: space.scheduleEnd,
                status: types_1.ChatStatus.ACTIVE,
            });
            // update space data
            this.setSpaceData((oldSpaceData) => {
                return (0, immer_1.produce)(oldSpaceData, (draft) => {
                    draft = Object.assign(Object.assign({}, (0, helpers_1.groupDtoToSpaceDto)(group)), { connectionData: draft.connectionData });
                    draft.connectionData.meta.broadcast = {
                        livepeerInfo: null,
                        hostAddress: this.data.local.address,
                    };
                });
            });
            // start the livepeer playback and store the playback URL group meta
            // send a notification/meta message to all the added listeners (members) telling the space has started
            // create the mergeStream object
            const mergeStreamObject = (0, getMergeStreamObject_1.default)(this.data.local.stream);
            // store the mergeStreamObject
            this.mergeStreamObject = mergeStreamObject;
            const url = 'https://livepeer.studio/api/stream';
            const data = {
                name: this.spaceSpecificData.spaceName,
                record: true,
            };
            const { data: responseData } = yield axios_1.default.post(url, data, {
                headers: {
                    Authorization: 'Bearer ' + livepeerApiKey,
                },
            });
            const { streamKey, playbackId } = responseData;
            console.log('livepeer details', streamKey, playbackId);
            // TODO: store the playbackId on group meta data, temp -> groupDescription
            this.update({ spaceDescription: playbackId });
            if (!(0, webrtmp_sdk_1.isSupported)()) {
                console.log('webrtmp-sdk is not currently supported on this browser');
            }
            // cast to the stream
            const client = new webrtmp_sdk_1.Client();
            const session = client.cast(mergeStreamObject.result, streamKey);
            session.on('open', () => {
                console.log('Live stream started.');
                // TODO: Update the space data
            });
            session.on('close', () => {
                console.log('Live stream stopped.');
                // TODO: Update the space data
            });
            session.on('error', (err) => {
                console.log('Live stream error.', err.message);
                // TODO: Update the space data
            });
        }
        catch (err) {
            console.error(`[Push SDK] - API  - Error - API ${start.name} -:  `, err);
            throw Error(`[Push SDK] - API  - Error - API ${start.name} -: ${err}`);
        }
    });
}
exports.start = start;
//# sourceMappingURL=start.js.map