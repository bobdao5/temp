"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.send = void 0;
const tslib_1 = require("tslib");
const axios_1 = require("axios");
const helpers_1 = require("../helpers");
const constants_1 = require("../constants");
const helpers_2 = require("./helpers");
const conversationHash_1 = require("./conversationHash");
const helpers_3 = require("./helpers");
const getGroup_1 = require("./getGroup");
/**
 * SENDS A PUSH CHAT MESSAGE
 */
const send = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { messageType = 'Text', receiverAddress, pgpPrivateKey = null, account = null, signer = null, env = constants_1.default.ENV.PROD, } = options || {};
    try {
        yield validateOptions(options);
        const wallet = (0, helpers_2.getWallet)({ account, signer });
        const sender = yield (0, helpers_2.getConnectedUserV2)(wallet, pgpPrivateKey, env);
        const receiver = yield (0, helpers_2.getUserDID)(receiverAddress, env);
        const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
        const isGroup = (0, helpers_1.isValidETHAddress)(receiverAddress) ? false : true;
        const group = isGroup
            ? yield (0, getGroup_1.getGroup)({
                chatId: receiverAddress,
                env: env,
            })
            : null;
        let messageObj = options.messageObj;
        // possible for initial types 'Text', 'Image', 'File', 'GIF', 'MediaEmbed'
        if (!messageObj) {
            messageObj = {
                content: options.messageContent ? options.messageContent : '',
            };
        }
        const messageContent = messageObj.content; // provide backward compatibility & override deprecated field
        const conversationResponse = yield (0, conversationHash_1.conversationHash)({
            conversationId: receiver,
            account: sender.did,
            env,
        });
        let apiEndpoint;
        if (!isGroup && conversationResponse && !(conversationResponse === null || conversationResponse === void 0 ? void 0 : conversationResponse.threadHash)) {
            apiEndpoint = `${API_BASE_URL}/v1/chat/request`;
        }
        else {
            apiEndpoint = `${API_BASE_URL}/v1/chat/message`;
        }
        const body = yield (0, helpers_3.sendMessagePayload)(receiver, sender, messageObj, messageContent, messageType, group, env);
        return (yield axios_1.default.post(apiEndpoint, body)).data;
    }
    catch (err) {
        console.error(`[Push SDK] - API  - Error - API ${exports.send.name} -:  `, err);
        throw Error(`[Push SDK] - API  - Error - API ${exports.send.name} -: ${err}`);
    }
});
exports.send = send;
const validateOptions = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { messageType = 'Text', messageObj, messageContent, receiverAddress, pgpPrivateKey = null, account = null, signer = null, env, } = options;
    if (!account && !signer) {
        throw new Error(`Unable to detect sender. Please ensure that either 'account' or 'signer' is properly defined.`);
    }
    if (!signer && !pgpPrivateKey) {
        throw new Error(`Unable to decrypt keys. Please ensure that either 'signer' or 'pgpPrivateKey' is properly defined.`);
    }
    const wallet = (0, helpers_2.getWallet)({ account, signer });
    const address = yield (0, helpers_2.getAccountAddress)(wallet);
    if (!(0, helpers_1.isValidETHAddress)(address)) {
        throw new Error(`Invalid sender. Please ensure that either 'account' or 'signer' is properly defined.`);
    }
    const isGroup = (0, helpers_1.isValidETHAddress)(receiverAddress) ? false : true;
    if (isGroup) {
        const group = yield (0, getGroup_1.getGroup)({
            chatId: receiverAddress,
            env: env,
        });
        if (!group) {
            throw new Error(`Invalid receiver. Please ensure 'receiver' is a valid DID or ChatId in case of Group.`);
        }
    }
    if (messageType === constants_1.MessageType.META) {
        if (!(messageObj instanceof Object) ||
            !(messageObj.meta instanceof Object) ||
            !('action' in messageObj.meta) ||
            !('info' in messageObj.meta) ||
            !(messageObj.meta.info.affected instanceof Array)) {
            throw new Error(`Unable to parse this messageType. Please ensure 'messageObj' is properly defined.`);
        }
    }
    else {
        if (messageObj && messageObj.meta) {
            throw new Error(`Unable to parse this messageType. Meta is not allowed for this messageType.`);
        }
    }
    if (!pgpPrivateKey) {
        // WARNING - WALLET SIGNING POPUPS
    }
    if (messageContent) {
        // WARNING - DEPRECATED AND TO BE REMOVED IN UPCOMING MAJOR RELEASE
    }
});
//# sourceMappingURL=send.js.map